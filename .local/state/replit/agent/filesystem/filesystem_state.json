{"file_contents":{"app.py":{"content":"import os\nimport logging\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\n# create the app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1) # needed for url_for to generate with https\n\n# configure the database, relative to the app instance folder\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\n# File upload configuration\napp.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB max file size\napp.config['UPLOAD_FOLDER'] = 'uploads'\n\n# initialize the app with the extension, flask-sqlalchemy >= 3.0.x\ndb.init_app(app)\n\nwith app.app_context():\n    # Make sure to import the models here or their tables won't be created\n    import models  # noqa: F401\n    db.create_all()\n    logging.info(\"Database tables created\")\n\n# Import routes to register them with the app\nimport app_routes  # noqa: F401\n","size_bytes":1300},"main.py":{"content":"from app import app\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n","size_bytes":99},"models.py":{"content":"from datetime import datetime\nfrom app import db\nfrom flask_dance.consumer.storage.sqla import OAuthConsumerMixin\nfrom flask_login import UserMixin\nfrom sqlalchemy import UniqueConstraint\n\n# (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.\nclass User(UserMixin, db.Model):\n    __tablename__ = 'users'\n    id = db.Column(db.String, primary_key=True)\n    email = db.Column(db.String, unique=True, nullable=True)\n    first_name = db.Column(db.String, nullable=True)\n    last_name = db.Column(db.String, nullable=True)\n    profile_image_url = db.Column(db.String, nullable=True)\n    role = db.Column(db.String, default='user')  # user, admin\n    \n    created_at = db.Column(db.DateTime, default=datetime.now)\n    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)\n\n# (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.\nclass OAuth(OAuthConsumerMixin, db.Model):\n    user_id = db.Column(db.String, db.ForeignKey(User.id))\n    browser_session_key = db.Column(db.String, nullable=False)\n    user = db.relationship(User)\n\n    __table_args__ = (UniqueConstraint(\n        'user_id',\n        'browser_session_key',\n        'provider',\n        name='uq_user_browser_session_key_provider',\n    ),)\n\nclass Upload(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.String, db.ForeignKey(User.id), nullable=False)\n    filename = db.Column(db.String, nullable=False)\n    original_filename = db.Column(db.String, nullable=False)\n    file_size = db.Column(db.Integer, nullable=False)\n    file_hash = db.Column(db.String, nullable=True)\n    upload_time = db.Column(db.DateTime, default=datetime.now)\n    \n    user = db.relationship(User, backref='uploads')\n\nclass Job(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.String, db.ForeignKey(User.id), nullable=False)\n    job_type = db.Column(db.String, nullable=False)  # brute_force, scan, etc.\n    status = db.Column(db.String, default='running')  # running, completed, cancelled, failed\n    progress = db.Column(db.Integer, default=0)\n    result = db.Column(db.Text, nullable=True)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    completed_at = db.Column(db.DateTime, nullable=True)\n    \n    user = db.relationship(User, backref='jobs')\n\nclass ScanResult(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.String, db.ForeignKey(User.id), nullable=False)\n    scan_type = db.Column(db.String, nullable=False)  # url, file, vulnerability\n    target = db.Column(db.String, nullable=False)\n    result = db.Column(db.Text, nullable=False)\n    risk_level = db.Column(db.String, nullable=True)  # low, medium, high\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    user = db.relationship(User, backref='scan_results')\n\nclass ActivityLog(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.String, db.ForeignKey(User.id), nullable=True)\n    action = db.Column(db.String, nullable=False)\n    details = db.Column(db.Text, nullable=True)\n    ip_address = db.Column(db.String, nullable=True)  # Internal/container IP\n    user_public_ip = db.Column(db.String, nullable=True)  # Real public IP\n    user_agent = db.Column(db.String, nullable=True)\n    created_at = db.Column(db.DateTime, default=datetime.now)\n    \n    user = db.relationship(User, backref='activity_logs')\n","size_bytes":3437},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"flask-dance>=7.1.0\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"flask-login>=0.6.3\",\n    \"oauthlib>=3.3.1\",\n    \"pyjwt>=2.10.1\",\n    \"cryptography>=45.0.6\",\n    \"requests>=2.32.5\",\n    \"pypdf2>=3.0.1\",\n    \"python-docx>=1.2.0\",\n    \"sqlalchemy>=2.0.43\",\n    \"werkzeug>=3.1.3\",\n    \"dnspython>=2.7.0\",\n    \"python-whois>=0.9.5\",\n    \"pillow>=11.3.0\",\n]\n","size_bytes":597},"replit.md":{"content":"# Overview\n\nCyberSec Dashboard is a comprehensive Flask-based cybersecurity web application designed for security professionals, researchers, and enthusiasts. The platform provides a suite of 9 security tools including hash calculation, file encryption/decryption, password cracking, vulnerability scanning, malware detection, password strength analysis, and comprehensive network diagnostic tools. The application features a dark Matrix-themed UI with neon green accents and animated background effects, creating an immersive cybersecurity environment.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Theme**: Dark Matrix theme with neon green (#00ff66) accents and animated Matrix rain background\n- **Framework**: Bootstrap 5.3.0 for responsive design and components\n- **Styling**: Custom CSS with CSS variables for consistent theming and glowing hover effects\n- **JavaScript**: Vanilla JavaScript for interactive features and Matrix rain animation\n- **Responsive Design**: 3-column desktop layout that collapses to single-column on mobile devices\n- **Module Navigation**: Dynamic modal system with URL parameter support for direct module access\n\n## Backend Architecture\n- **Framework**: Flask with SQLAlchemy ORM for database operations\n- **Authentication**: Replit OAuth integration with Flask-Login for session management\n- **File Handling**: Werkzeug secure filename handling with 50MB upload limit\n- **Security**: CSRF protection, input validation, and file MIME type restrictions\n- **Architecture Pattern**: Blueprint-based modular design for scalable route organization\n- **Network Operations**: Container-optimized network diagnostic tools with fallback implementations\n- **Activity Logging**: Comprehensive logging system for all security operations and network diagnostics\n\n## Database Schema\n- **Users Table**: Stores user profiles with role-based access (user/admin)\n- **OAuth Table**: Manages OAuth tokens and browser sessions for Replit authentication\n- **Uploads Table**: Tracks file uploads with metadata (filename, size, hash)\n- **Jobs Table**: Manages background tasks (password cracking, scanning) with progress tracking\n- **Additional Tables**: ScanResult and ActivityLog for security operations and audit trails\n\n## Security Modules\n- **Hash Calculator**: MD5, SHA-1, SHA-256, SHA-512 generation and comparison\n- **File Encryption**: AES encryption/decryption with PBKDF2 key derivation\n- **Password Cracker**: Brute force attack simulation for PDF, ZIP, DOCX files with real-time progress\n- **URL Scanner**: Basic safety checks for suspicious patterns and connectivity\n- **Vulnerability Scanner**: SQLi/XSS detection and passive security analysis\n- **Malware Scanner**: File analysis for potential threats\n- **Hash Comparison**: Side-by-side hash comparison for file integrity verification\n- **Password Strength Analyzer**: Comprehensive password security analysis with entropy calculation, pattern detection, and detailed recommendations\n- **Network Tools**: Comprehensive network diagnostic utilities including ping, DNS lookup, port scanning, traceroute, WHOIS lookup, and network information analysis\n\n## Authorization System\n- **Role-based Access**: User and admin roles with different permission levels\n- **Admin Panel**: System monitoring, user management, and activity logging\n- **Session Management**: Persistent sessions with proper logout handling\n\n# External Dependencies\n\n## Core Framework Dependencies\n- **Flask**: Web framework with SQLAlchemy extension for database ORM\n- **Flask-Login**: User session management and authentication\n- **Flask-Dance**: OAuth integration specifically configured for Replit authentication\n- **Werkzeug**: WSGI utilities including ProxyFix for HTTPS URL generation\n\n## Frontend Libraries\n- **Bootstrap 5.3.0**: CSS framework from CDN for responsive design\n- **Font Awesome 6.4.0**: Icon library from CDN for UI elements\n\n## Cryptography Libraries\n- **cryptography**: AES encryption/decryption with Fernet and PBKDF2 key derivation\n- **hashlib**: Built-in Python library for hash calculations\n\n## File Processing Libraries\n- **PyPDF2**: PDF file manipulation and password verification\n- **python-docx**: Microsoft Word document processing\n- **zipfile**: Built-in Python library for ZIP archive handling\n\n## HTTP and Security\n- **requests**: HTTP client library for URL scanning and external API calls\n- **JWT**: JSON Web Token handling for authentication tokens\n- **bcrypt**: Password hashing (implied for secure authentication)\n\n## Network Diagnostic Tools\n- **socket**: Built-in Python library for network connections and port scanning\n- **subprocess**: System command execution for network utilities\n- **re**: Regular expressions for parsing network command outputs\n- **time**: Timing measurements for connectivity tests\n\n## System Dependencies\n- **iputils**: Network utilities package providing ping functionality\n- **traceroute**: Network route tracing utility for path analysis\n- **whois**: Domain registration information lookup utility\n- **dnsutils**: DNS lookup and resolution utilities\n\n## Database Configuration\n- **SQLAlchemy**: Database abstraction layer with connection pooling\n- **Database URL**: Configured via environment variable for flexible deployment\n- **Connection Pool**: 300-second recycle time with pre-ping for connection health\n\n## Environment Configuration\n- **SESSION_SECRET**: Environment variable for Flask session encryption\n- **DATABASE_URL**: Database connection string from environment\n- **File Upload Directory**: Configurable upload folder with size restrictions\n\n# Recent Changes\n\n## Network Tools Implementation (Latest Update)\n- **Complete Network Diagnostic Suite**: 6 comprehensive network tools in tabbed interface\n- **Container-Optimized Implementation**: Custom implementations for container environments without raw socket access\n- **Ping Tool**: TCP connectivity testing with timing statistics and packet loss calculation\n- **DNS Lookup**: Multi-record type resolution (A, AAAA, MX, NS, TXT, CNAME)\n- **Port Scanner**: TCP port scanning with configurable port ranges (security limited to 50 ports)\n- **Traceroute**: Network path analysis with estimated route information and actual connectivity testing\n- **WHOIS Lookup**: Domain information retrieval with HTTP fallback when traditional WHOIS unavailable\n- **Network Info**: Local network status and connectivity analysis\n- **Professional UI**: Bootstrap 5 tabbed interface with real-time results and error handling\n- **Activity Logging**: All network operations logged for security monitoring\n- **Module Navigation**: Enhanced home page integration with URL parameter redirection to dashboard\n- **Error Resilience**: Comprehensive fallback mechanisms for constrained environments\n\n## Security & Performance Features\n- **Input Validation**: All network inputs sanitized and validated\n- **Rate Limiting**: Port scanning limited to prevent abuse\n- **Timeout Protection**: All network operations have configurable timeouts\n- **Fallback Implementations**: Alternative methods when system commands unavailable\n- **Real-time Results**: Dynamic result display with formatted output and statistics","size_bytes":7239},"replit_auth.py":{"content":"import jwt\nimport os\nimport uuid\nfrom functools import wraps\nfrom urllib.parse import urlencode\n\nfrom flask import g, session, redirect, request, render_template, url_for\nfrom flask_dance.consumer import (\n    OAuth2ConsumerBlueprint,\n    oauth_authorized,\n    oauth_error,\n)\nfrom flask_dance.consumer.storage import BaseStorage\nfrom flask_login import LoginManager, login_user, logout_user, current_user\nfrom oauthlib.oauth2.rfc6749.errors import InvalidGrantError\nfrom sqlalchemy.exc import NoResultFound\nfrom werkzeug.local import LocalProxy\n\nfrom app import app, db\nfrom models import OAuth, User\n\nlogin_manager = LoginManager(app)\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(user_id)\n\nclass UserSessionStorage(BaseStorage):\n    def get(self, blueprint):\n        try:\n            token = db.session.query(OAuth).filter_by(\n                user_id=current_user.get_id(),\n                browser_session_key=g.browser_session_key,\n                provider=blueprint.name,\n            ).one().token\n        except NoResultFound:\n            token = None\n        return token\n\n    def set(self, blueprint, token):\n        db.session.query(OAuth).filter_by(\n            user_id=current_user.get_id(),\n            browser_session_key=g.browser_session_key,\n            provider=blueprint.name,\n        ).delete()\n        new_model = OAuth()\n        new_model.user_id = current_user.get_id()\n        new_model.browser_session_key = g.browser_session_key\n        new_model.provider = blueprint.name\n        new_model.token = token\n        db.session.add(new_model)\n        db.session.commit()\n\n    def delete(self, blueprint):\n        db.session.query(OAuth).filter_by(\n            user_id=current_user.get_id(),\n            browser_session_key=g.browser_session_key,\n            provider=blueprint.name).delete()\n        db.session.commit()\n\ndef make_replit_blueprint():\n    try:\n        repl_id = os.environ['REPL_ID']\n    except KeyError:\n        raise SystemExit(\"the REPL_ID environment variable must be set\")\n\n    issuer_url = os.environ.get('ISSUER_URL', \"https://replit.com/oidc\")\n\n    replit_bp = OAuth2ConsumerBlueprint(\n        \"replit_auth\",\n        __name__,\n        client_id=repl_id,\n        client_secret=None,\n        base_url=issuer_url,\n        authorization_url_params={\n            \"prompt\": \"login consent\",\n        },\n        token_url=issuer_url + \"/token\",\n        token_url_params={\n            \"auth\": (),\n            \"include_client_id\": True,\n        },\n        auto_refresh_url=issuer_url + \"/token\",\n        auto_refresh_kwargs={\n            \"client_id\": repl_id,\n        },\n        authorization_url=issuer_url + \"/auth\",\n        use_pkce=True,\n        code_challenge_method=\"S256\",\n        scope=[\"openid\", \"profile\", \"email\", \"offline_access\"],\n        storage=UserSessionStorage(),\n    )\n\n    @replit_bp.before_app_request\n    def set_applocal_session():\n        if '_browser_session_key' not in session:\n            session['_browser_session_key'] = uuid.uuid4().hex\n        session.modified = True\n        g.browser_session_key = session['_browser_session_key']\n        g.flask_dance_replit = replit_bp.session\n\n    @replit_bp.route(\"/logout\")\n    def logout():\n        del replit_bp.token\n        logout_user()\n\n        end_session_endpoint = issuer_url + \"/session/end\"\n        encoded_params = urlencode({\n            \"client_id\": repl_id,\n            \"post_logout_redirect_uri\": request.url_root,\n        })\n        logout_url = f\"{end_session_endpoint}?{encoded_params}\"\n\n        return redirect(logout_url)\n\n    @replit_bp.route(\"/error\")\n    def error():\n        return render_template(\"403.html\"), 403\n\n    return replit_bp\n\ndef save_user(user_claims):\n    user = User()\n    user.id = user_claims['sub']\n    user.email = user_claims.get('email')\n    user.first_name = user_claims.get('first_name')\n    user.last_name = user_claims.get('last_name')\n    user.profile_image_url = user_claims.get('profile_image_url')\n    merged_user = db.session.merge(user)\n    db.session.commit()\n    return merged_user\n\n@oauth_authorized.connect\ndef logged_in(blueprint, token):\n    user_claims = jwt.decode(token['id_token'], options={\"verify_signature\": False})\n    user = save_user(user_claims)\n    login_user(user)\n    blueprint.token = token\n    next_url = session.pop(\"next_url\", None)\n    if next_url is not None:\n        return redirect(next_url)\n\n@oauth_error.connect\ndef handle_error(blueprint, error, error_description=None, error_uri=None):\n    return redirect(url_for('replit_auth.error'))\n\ndef require_login(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not current_user.is_authenticated:\n            session[\"next_url\"] = get_next_navigation_url(request)\n            return redirect(url_for('replit_auth.login'))\n\n        expires_in = replit.token.get('expires_in', 0)\n        if expires_in < 0:\n            issuer_url = os.environ.get('ISSUER_URL', \"https://replit.com/oidc\")\n            refresh_token_url = issuer_url + \"/token\"\n            try:\n                token = replit.refresh_token(token_url=refresh_token_url, client_id=os.environ['REPL_ID'])\n            except InvalidGrantError:\n                session[\"next_url\"] = get_next_navigation_url(request)\n                return redirect(url_for('replit_auth.login'))\n            replit.token_updater(token)\n\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef get_next_navigation_url(request):\n    is_navigation_url = request.headers.get('Sec-Fetch-Mode') == 'navigate' and request.headers.get('Sec-Fetch-Dest') == 'document'\n    if is_navigation_url:\n        return request.url\n    return request.referrer or request.url\n\nreplit = LocalProxy(lambda: g.flask_dance_replit)\n","size_bytes":5750},"utils/crypto_utils.py":{"content":"import os\nimport base64\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\ndef generate_key_from_password(password, salt=None):\n    \"\"\"Generate encryption key from password\"\"\"\n    if salt is None:\n        salt = os.urandom(16)\n    \n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=100000,\n    )\n    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n    return key, salt\n\ndef encrypt_file(file_path, password):\n    \"\"\"Encrypt a file with AES using password\"\"\"\n    key, salt = generate_key_from_password(password)\n    fernet = Fernet(key)\n    \n    # Read original file\n    with open(file_path, 'rb') as f:\n        file_data = f.read()\n    \n    # Encrypt data\n    encrypted_data = fernet.encrypt(file_data)\n    \n    # Write encrypted file with salt prefix\n    encrypted_path = file_path + '.encrypted'\n    with open(encrypted_path, 'wb') as f:\n        f.write(salt + encrypted_data)\n    \n    # Remove original file for security\n    os.remove(file_path)\n    \n    return encrypted_path\n\ndef decrypt_file(file_path, password):\n    \"\"\"Decrypt a file with AES using password\"\"\"\n    # Read encrypted file\n    with open(file_path, 'rb') as f:\n        encrypted_data = f.read()\n    \n    # Extract salt and encrypted content\n    salt = encrypted_data[:16]\n    encrypted_content = encrypted_data[16:]\n    \n    # Generate key from password and salt\n    key, _ = generate_key_from_password(password, salt)\n    fernet = Fernet(key)\n    \n    try:\n        # Decrypt data\n        decrypted_data = fernet.decrypt(encrypted_content)\n        \n        # Write decrypted file\n        decrypted_path = file_path.replace('.encrypted', '.decrypted')\n        with open(decrypted_path, 'wb') as f:\n            f.write(decrypted_data)\n        \n        return decrypted_path\n        \n    except Exception as e:\n        raise Exception(\"Invalid password or corrupted file\")\n","size_bytes":2023},"utils/hash_utils.py":{"content":"import hashlib\n\ndef calculate_hash(data, hash_type):\n    \"\"\"Calculate hash of data\"\"\"\n    if isinstance(data, str):\n        data = data.encode()\n    \n    hash_type = hash_type.lower()\n    \n    if hash_type == 'md5':\n        return hashlib.md5(data).hexdigest()\n    elif hash_type == 'sha1':\n        return hashlib.sha1(data).hexdigest()\n    elif hash_type == 'sha256':\n        return hashlib.sha256(data).hexdigest()\n    elif hash_type == 'sha512':\n        return hashlib.sha512(data).hexdigest()\n    else:\n        raise ValueError(f\"Unsupported hash type: {hash_type}\")\n\ndef compare_hashes(data1, data2, hash_type='sha256'):\n    \"\"\"Compare hashes of two data sets\"\"\"\n    hash1 = calculate_hash(data1, hash_type)\n    hash2 = calculate_hash(data2, hash_type)\n    \n    return {\n        'hash1': hash1,\n        'hash2': hash2,\n        'match': hash1 == hash2\n    }\n","size_bytes":862},"utils/password_analyzer.py":{"content":"import re\nimport math\nfrom collections import Counter\n\n# Common weak passwords\nCOMMON_PASSWORDS = [\n    'password', '123456', 'password123', 'admin', 'letmein', 'welcome',\n    'monkey', '1234567890', 'qwerty', 'abc123', 'Password1', '123123',\n    'hello', 'login', 'pass', 'test', 'guest', 'user', 'root', 'default',\n    '12345', 'password1', 'admin123', 'iloveyou', 'princess', 'rockyou',\n    'football', 'baseball', 'basketball', 'dragon', 'superman', 'michael',\n    'jennifer', 'jordan', 'michelle', 'daniel', 'jessica', 'matthew'\n]\n\n# Common keyboard patterns\nKEYBOARD_PATTERNS = [\n    'qwerty', 'asdf', 'zxcv', '1234', 'abcd', '!@#$',\n    'qwertyuiop', 'asdfghjkl', 'zxcvbnm', '1234567890'\n]\n\ndef calculate_entropy(password):\n    \"\"\"Calculate password entropy\"\"\"\n    if not password:\n        return 0\n    \n    # Character set size\n    charset_size = 0\n    if re.search(r'[a-z]', password):\n        charset_size += 26\n    if re.search(r'[A-Z]', password):\n        charset_size += 26\n    if re.search(r'[0-9]', password):\n        charset_size += 10\n    if re.search(r'[^a-zA-Z0-9]', password):\n        charset_size += 32  # Common special characters\n    \n    # Calculate entropy\n    entropy = len(password) * math.log2(charset_size) if charset_size > 0 else 0\n    return round(entropy, 2)\n\ndef check_password_patterns(password):\n    \"\"\"Check for common patterns in password\"\"\"\n    patterns_found = []\n    \n    # Check for keyboard patterns\n    for pattern in KEYBOARD_PATTERNS:\n        if pattern.lower() in password.lower():\n            patterns_found.append(f\"Keyboard pattern: {pattern}\")\n    \n    # Check for repeated characters\n    for i in range(len(password) - 2):\n        if password[i] == password[i+1] == password[i+2]:\n            patterns_found.append(f\"Repeated character: {password[i]*3}\")\n            break\n    \n    # Check for sequential numbers\n    for i in range(len(password) - 2):\n        if password[i:i+3].isdigit():\n            nums = [int(password[i+j]) for j in range(3)]\n            if nums[1] == nums[0] + 1 and nums[2] == nums[1] + 1:\n                patterns_found.append(f\"Sequential numbers: {password[i:i+3]}\")\n                break\n    \n    # Check for sequential letters\n    for i in range(len(password) - 2):\n        if password[i:i+3].isalpha():\n            chars = password[i:i+3].lower()\n            if ord(chars[1]) == ord(chars[0]) + 1 and ord(chars[2]) == ord(chars[1]) + 1:\n                patterns_found.append(f\"Sequential letters: {password[i:i+3]}\")\n                break\n    \n    return patterns_found\n\ndef analyze_password_strength(password):\n    \"\"\"Comprehensive password strength analysis\"\"\"\n    if not password:\n        return {\n            'score': 0,\n            'strength': 'Very Weak',\n            'feedback': ['Password cannot be empty'],\n            'details': {},\n            'entropy': 0,\n            'estimated_crack_time': 'Instant'\n        }\n    \n    score = 0\n    feedback = []\n    details = {}\n    \n    # Length check\n    length = len(password)\n    details['length'] = length\n    if length >= 12:\n        score += 25\n        details['length_score'] = 'Excellent'\n    elif length >= 8:\n        score += 15\n        details['length_score'] = 'Good'\n        feedback.append('Consider using 12+ characters for better security')\n    elif length >= 6:\n        score += 8\n        details['length_score'] = 'Fair'\n        feedback.append('Password should be at least 8 characters long')\n    else:\n        score += 0\n        details['length_score'] = 'Poor'\n        feedback.append('Password is too short (minimum 6 characters)')\n    \n    # Character variety checks\n    has_lower = bool(re.search(r'[a-z]', password))\n    has_upper = bool(re.search(r'[A-Z]', password))\n    has_digit = bool(re.search(r'[0-9]', password))\n    has_special = bool(re.search(r'[^a-zA-Z0-9]', password))\n    \n    char_variety = sum([has_lower, has_upper, has_digit, has_special])\n    details['character_variety'] = {\n        'lowercase': has_lower,\n        'uppercase': has_upper,\n        'digits': has_digit,\n        'special_chars': has_special,\n        'variety_count': char_variety\n    }\n    \n    if char_variety >= 4:\n        score += 25\n        details['variety_score'] = 'Excellent'\n    elif char_variety >= 3:\n        score += 18\n        details['variety_score'] = 'Good'\n        if not has_special:\n            feedback.append('Add special characters for better security')\n    elif char_variety >= 2:\n        score += 10\n        details['variety_score'] = 'Fair'\n        feedback.append('Include more character types (uppercase, digits, symbols)')\n    else:\n        score += 0\n        details['variety_score'] = 'Poor'\n        feedback.append('Use a mix of uppercase, lowercase, numbers, and symbols')\n    \n    # Common password check\n    is_common = password.lower() in [p.lower() for p in COMMON_PASSWORDS]\n    details['is_common_password'] = is_common\n    if is_common:\n        score -= 30\n        feedback.append('This is a commonly used password - avoid it!')\n    else:\n        score += 15\n    \n    # Pattern detection\n    patterns = check_password_patterns(password)\n    details['patterns_found'] = patterns\n    if patterns:\n        score -= len(patterns) * 10\n        feedback.extend([f\"Avoid predictable patterns: {p}\" for p in patterns])\n    else:\n        score += 10\n    \n    # Dictionary word check (simple)\n    words = re.findall(r'[a-zA-Z]{4,}', password)\n    common_words = ['love', 'hate', 'work', 'home', 'life', 'time', 'year', 'good', 'best']\n    found_words = [word for word in words if word.lower() in common_words]\n    details['dictionary_words'] = found_words\n    if found_words:\n        score -= len(found_words) * 5\n        feedback.append('Avoid using common dictionary words')\n    \n    # Character frequency analysis\n    char_freq = Counter(password.lower())\n    most_common_char, freq = char_freq.most_common(1)[0]\n    details['most_frequent_char'] = {'char': most_common_char, 'frequency': freq}\n    if freq > len(password) * 0.3:  # More than 30% of password is same character\n        score -= 15\n        feedback.append('Avoid repeating the same character too often')\n    \n    # Calculate entropy\n    entropy = calculate_entropy(password)\n    details['entropy'] = entropy\n    \n    # Estimate crack time (simplified)\n    if entropy < 30:\n        crack_time = 'Less than 1 hour'\n    elif entropy < 40:\n        crack_time = 'Few hours to days'\n    elif entropy < 50:\n        crack_time = 'Weeks to months'\n    elif entropy < 60:\n        crack_time = 'Years to decades'\n    else:\n        crack_time = 'Centuries or more'\n    \n    # Normalize score\n    score = max(0, min(100, score))\n    \n    # Determine strength level\n    if score >= 80:\n        strength = 'Very Strong'\n        strength_color = 'success'\n    elif score >= 60:\n        strength = 'Strong'\n        strength_color = 'info'\n    elif score >= 40:\n        strength = 'Fair'\n        strength_color = 'warning'\n    elif score >= 20:\n        strength = 'Weak'\n        strength_color = 'warning'\n    else:\n        strength = 'Very Weak'\n        strength_color = 'danger'\n    \n    # Generate positive feedback for strong passwords\n    if score >= 70 and not feedback:\n        feedback.append('Great password! Strong and secure.')\n    \n    return {\n        'score': score,\n        'strength': strength,\n        'strength_color': strength_color,\n        'feedback': feedback if feedback else ['Password meets basic security requirements'],\n        'details': details,\n        'entropy': entropy,\n        'estimated_crack_time': crack_time\n    }\n\ndef generate_password_suggestions():\n    \"\"\"Generate suggestions for creating strong passwords\"\"\"\n    return [\n        \"Use a passphrase with 4+ random words (e.g., 'Coffee-Tree-Moon-42!')\",\n        \"Combine unrelated words with numbers and symbols\",\n        \"Use the first letters of a memorable sentence\",\n        \"Replace some letters with numbers or symbols (but avoid obvious substitutions)\",\n        \"Make it at least 12 characters long\",\n        \"Avoid personal information (names, birthdays, addresses)\",\n        \"Don't use keyboard patterns or repeated characters\",\n        \"Consider using a password manager to generate strong passwords\"\n    ]","size_bytes":8227},"utils/password_cracker.py":{"content":"import os\nimport time\nimport threading\nimport zipfile\nimport PyPDF2\nfrom docx import Document\nfrom app import db\nfrom models import Job\n\n# Common passwords for brute force\nCOMMON_PASSWORDS = [\n    'password', '123456', 'password123', 'admin', 'letmein', 'welcome',\n    'monkey', '1234567890', 'qwerty', 'abc123', 'Password1', '123123',\n    'hello', 'login', 'pass', 'test', 'guest', 'user', 'root', 'default'\n]\n\nWORDLIST_PASSWORDS = {\n    'common': COMMON_PASSWORDS,\n    'numbers': [str(i).zfill(4) for i in range(10000)],\n    'years': [str(year) for year in range(1900, 2030)]\n}\n\ndef check_file_unlocked(file_path):\n    \"\"\"Check if file is already unlocked/has no password\"\"\"\n    file_type = detect_file_type(file_path)\n    \n    if file_type == 'zip':\n        try:\n            with zipfile.ZipFile(file_path, 'r') as zip_file:\n                # Try to get file info without password\n                zip_file.infolist()\n                return True  # File is not password protected\n        except (RuntimeError, zipfile.BadZipFile):\n            return False  # File is encrypted or corrupted\n            \n    elif file_type == 'pdf':\n        try:\n            with open(file_path, 'rb') as file:\n                pdf_reader = PyPDF2.PdfReader(file)\n                return not pdf_reader.is_encrypted  # True if not encrypted\n        except:\n            return False\n            \n    elif file_type == 'office':\n        try:\n            doc = Document(file_path)\n            return True  # File opened successfully without password\n        except:\n            return False  # File is encrypted or corrupted\n    \n    return False\n\ndef try_password_zip(file_path, password):\n    \"\"\"Try to extract a ZIP file with given password\"\"\"\n    try:\n        with zipfile.ZipFile(file_path, 'r') as zip_file:\n            zip_file.extractall(pwd=password.encode())\n        return True\n    except (RuntimeError, zipfile.BadZipFile):\n        return False\n\ndef try_password_pdf(file_path, password):\n    \"\"\"Try to open a PDF file with given password\"\"\"\n    try:\n        with open(file_path, 'rb') as file:\n            pdf_reader = PyPDF2.PdfReader(file)\n            if pdf_reader.is_encrypted:\n                return pdf_reader.decrypt(password)\n            else:\n                return False  # File is not encrypted, so password attempt is meaningless\n    except:\n        return False\n\ndef try_password_docx(file_path, password):\n    \"\"\"Try to open a DOCX file with given password\"\"\"\n    try:\n        # For DOCX, if it opens without error, it's not password protected\n        # We need to actually try with password for encrypted files\n        doc = Document(file_path)\n        return False  # File is not password protected, so password attempt is meaningless\n    except:\n        return False\n\ndef detect_file_type(file_path):\n    \"\"\"Detect file type based on extension\"\"\"\n    ext = os.path.splitext(file_path)[1].lower()\n    \n    if ext == '.zip':\n        return 'zip'\n    elif ext == '.pdf':\n        return 'pdf'\n    elif ext in ['.docx', '.pptx', '.xlsx']:\n        return 'office'\n    else:\n        return 'unknown'\n\ndef load_custom_wordlist(file_path):\n    \"\"\"Load custom wordlist from file\"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8') as f:\n            passwords = [line.strip() for line in f.readlines() if line.strip()]\n        return passwords\n    except Exception as e:\n        print(f\"Error loading wordlist: {e}\")\n        return COMMON_PASSWORDS\n\ndef brute_force_worker(job_id, file_path, wordlist_type, custom_wordlist_path=None):\n    \"\"\"Background worker for brute force attack\"\"\"\n    from app import app\n    \n    with app.app_context():\n        try:\n            job = Job.query.get(job_id)\n            if not job:\n                return\n            \n            # First check if file is already unlocked\n            if check_file_unlocked(file_path):\n                job.status = 'completed'\n                job.result = 'File is already unlocked - no password required'\n                job.progress = 100\n                db.session.commit()\n                return\n            \n            file_type = detect_file_type(file_path)\n            \n            # Load passwords based on type\n            if wordlist_type == 'custom' and custom_wordlist_path:\n                passwords = load_custom_wordlist(custom_wordlist_path)\n            else:\n                passwords = WORDLIST_PASSWORDS.get(wordlist_type, COMMON_PASSWORDS)\n            \n            total_passwords = len(passwords)\n            \n            for i, password in enumerate(passwords):\n                # Check if job was cancelled\n                job = Job.query.get(job_id)\n                if not job or job.status == 'cancelled':\n                    break\n                \n                # Update current password being tested\n                job.result = f'Trying: {password}'\n                \n                # Try password based on file type\n                success = False\n                if file_type == 'zip':\n                    success = try_password_zip(file_path, password)\n                elif file_type == 'pdf':\n                    success = try_password_pdf(file_path, password)\n                elif file_type == 'office':\n                    success = try_password_docx(file_path, password)\n                \n                if success:\n                    if job:\n                        job.status = 'completed'\n                        job.result = f'Password found: {password}'\n                        job.progress = 100\n                        db.session.commit()\n                    return\n                \n                # Update progress\n                if job:\n                    progress = int((i + 1) / total_passwords * 100)\n                    job.progress = progress\n                    db.session.commit()\n                \n                time.sleep(0.1)  # Small delay for better UX\n            \n            # If we get here, no password was found\n            job = Job.query.get(job_id)\n            if job:\n                job.status = 'completed'\n                job.result = 'Password not found in wordlist'\n                job.progress = 100\n                db.session.commit()\n            \n        except Exception as e:\n            job = Job.query.get(job_id)\n            if job:\n                job.status = 'failed'\n                job.result = f'Error: {str(e)}'\n                db.session.commit()\n\ndef start_brute_force(job_id, file_path, wordlist_type, custom_wordlist_path=None):\n    \"\"\"Start brute force attack in background thread\"\"\"\n    thread = threading.Thread(\n        target=brute_force_worker,\n        args=(job_id, file_path, wordlist_type, custom_wordlist_path)\n    )\n    thread.daemon = True\n    thread.start()\n\ndef check_job_status(job_id):\n    \"\"\"Check status of brute force job\"\"\"\n    job = Job.query.get(job_id)\n    if not job:\n        return None\n    \n    return {\n        'status': job.status,\n        'progress': job.progress,\n        'result': job.result\n    }\n","size_bytes":7007},"utils/scanner_utils.py":{"content":"import re\nimport requests\nfrom urllib.parse import urlparse\nimport os\nimport socket\nimport ipaddress\n\ndef is_private_ip(ip_str):\n    \"\"\"Check if an IP address is in a private range\"\"\"\n    try:\n        ip = ipaddress.ip_address(ip_str)\n        # Check for private ranges\n        private_ranges = [\n            ipaddress.ip_network('127.0.0.0/8'),    # Loopback\n            ipaddress.ip_network('10.0.0.0/8'),     # Private Class A\n            ipaddress.ip_network('172.16.0.0/12'),  # Private Class B\n            ipaddress.ip_network('192.168.0.0/16'), # Private Class C\n            ipaddress.ip_network('169.254.0.0/16'), # Link-local\n            ipaddress.ip_network('::1/128'),        # IPv6 loopback\n            ipaddress.ip_network('fc00::/7'),       # IPv6 unique local\n            ipaddress.ip_network('fe80::/10'),      # IPv6 link-local\n        ]\n        return any(ip in network for network in private_ranges)\n    except (ValueError, ipaddress.AddressValueError):\n        return False\n\ndef validate_url_for_ssrf(url):\n    \"\"\"Validate URL to prevent SSRF attacks\"\"\"\n    try:\n        parsed = urlparse(url)\n        hostname = parsed.hostname\n        \n        if not hostname:\n            return False, \"Invalid hostname\"\n        \n        # Block common internal hostnames\n        blocked_hostnames = ['localhost', 'metadata.google.internal']\n        if hostname.lower() in blocked_hostnames:\n            return False, f\"Blocked hostname: {hostname}\"\n        \n        # Resolve hostname to IP addresses\n        try:\n            # Get all IP addresses for the hostname\n            addr_info = socket.getaddrinfo(hostname, None)\n            ips = [info[4][0] for info in addr_info]\n            \n            # Check if any resolved IP is private\n            for ip in ips:\n                if is_private_ip(ip):\n                    return False, f\"URL resolves to private IP: {ip}\"\n                    \n        except socket.gaierror:\n            return False, \"Unable to resolve hostname\"\n        \n        # Additional checks for direct IP addresses in URL\n        if re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', hostname):\n            if is_private_ip(hostname):\n                return False, f\"Direct private IP address: {hostname}\"\n                \n        return True, \"URL validation passed\"\n        \n    except Exception as e:\n        return False, f\"Validation error: {str(e)}\"\n\ndef scan_url(url):\n    \"\"\"Basic URL safety scan\"\"\"\n    try:\n        reasons = []\n        risk_factors = []\n        \n        # Validate URL format\n        parsed = urlparse(url)\n        if not parsed.scheme or not parsed.netloc:\n            return {\n                'safe': False,\n                'message': 'Invalid URL format',\n                'risk_level': 'high',\n                'reasons': ['URL format is malformed or incomplete', 'Missing protocol (http/https) or domain name', 'Could indicate phishing or malicious redirection']\n            }\n        \n        # Check for suspicious patterns\n        suspicious_patterns = {\n            r'bit\\.ly': 'URL shortener (bit.ly) - could hide destination',\n            r'tinyurl': 'URL shortener (tinyurl) - could hide destination', \n            r'shortened': 'URL shortener service - potential redirection risk',\n            r'phishing': 'Contains word \"phishing\" - highly suspicious',\n            r'malware': 'Contains word \"malware\" - highly suspicious',\n            r'virus': 'Contains word \"virus\" - highly suspicious',\n            r'[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}': 'Direct IP address - bypasses domain reputation checks'\n        }\n        \n        for pattern, reason in suspicious_patterns.items():\n            if re.search(pattern, url, re.IGNORECASE):\n                return {\n                    'safe': False,\n                    'message': f'Suspicious pattern detected: {pattern}',\n                    'risk_level': 'medium',\n                    'reasons': [reason, 'Suspicious patterns often indicate malicious intent', 'Legitimate sites rarely use such patterns']\n                }\n        \n        # Check domain reputation factors\n        domain = parsed.netloc.lower()\n        if domain.startswith('www.'):\n            domain = domain[4:]\n            \n        # Check for known safe domains (exact matching to prevent spoofing)\n        trusted_domains = ['google.com', 'microsoft.com', 'github.com', 'replit.com', 'stackoverflow.com']\n        is_trusted = False\n        for trusted_domain in trusted_domains:\n            if domain == trusted_domain or domain.endswith('.' + trusted_domain):\n                reasons.append('Domain belongs to a well-known trusted organization')\n                is_trusted = True\n                break\n            \n        # Check for HTTPS\n        if parsed.scheme == 'https':\n            reasons.append('Uses HTTPS encryption for secure communication')\n        else:\n            risk_factors.append('Uses HTTP instead of HTTPS - data not encrypted')\n            \n        # SSRF Protection: Validate URL before making requests\n        ssrf_valid, ssrf_message = validate_url_for_ssrf(url)\n        if not ssrf_valid:\n            return {\n                'safe': False,\n                'message': f'Security restriction: {ssrf_message}',\n                'risk_level': 'high',\n                'reasons': [\n                    ssrf_message,\n                    'URL blocked for security reasons',\n                    'This prevents attacks on internal services',\n                    'Only public URLs are allowed for scanning'\n                ]\n            }\n        \n        # Try to fetch headers (basic connectivity check) with SSRF protection\n        try:\n            response = requests.head(url, timeout=5, allow_redirects=True)\n            \n            # Validate final URL after redirects\n            final_url = response.url\n            if final_url != url:\n                final_valid, final_message = validate_url_for_ssrf(final_url)\n                if not final_valid:\n                    return {\n                        'safe': False,\n                        'message': f'Redirect blocked: {final_message}',\n                        'risk_level': 'high',\n                        'reasons': [\n                            f'URL redirected to blocked destination: {final_url}',\n                            final_message,\n                            'Redirect blocked for security reasons'\n                        ]\n                    }\n                reasons.append(f'Safe redirect: {url} â†’ {final_url}')\n            \n            if response.status_code >= 400:\n                return {\n                    'safe': False,\n                    'message': f'HTTP error: {response.status_code}',\n                    'risk_level': 'medium',\n                    'reasons': [f'Server returned error code {response.status_code}', 'Could indicate broken or malicious site', 'Legitimate sites typically return 200 OK status']\n                }\n            else:\n                reasons.append(f'Server responds properly (HTTP {response.status_code})')\n                \n            # Check security headers\n            security_headers = ['X-Frame-Options', 'X-XSS-Protection', 'X-Content-Type-Options']\n            present_headers = [h for h in security_headers if h in response.headers]\n            if present_headers:\n                reasons.append(f'Has security headers: {\", \".join(present_headers)}')\n                \n        except requests.RequestException as e:\n            return {\n                'safe': False,\n                'message': 'Unable to connect to URL',\n                'risk_level': 'medium',\n                'reasons': ['Connection failed - server may be down or unreachable', 'Could indicate suspicious or non-existent domain', 'Network issues or firewall blocking access']\n            }\n        \n        # Add basic safety indicators\n        reasons.extend([\n            'No suspicious patterns detected in URL',\n            'Basic connectivity and format checks passed',\n            'No obvious malicious indicators found'\n        ])\n        \n        if risk_factors:\n            reasons.extend(risk_factors)\n        \n        # Determine risk level and safety status based on actual risk factors\n        if len(risk_factors) >= 3:\n            risk_level = 'high'\n            message = 'URL has multiple risk factors - exercise extreme caution'\n            safe = False\n        elif len(risk_factors) >= 1:\n            risk_level = 'medium' \n            message = 'URL has some risk factors - proceed with caution'\n            safe = False\n        elif is_trusted:\n            risk_level = 'low'\n            message = 'URL appears safe (trusted domain)'\n            safe = True\n        else:\n            risk_level = 'low'\n            message = 'URL appears safe (basic checks passed)'\n            safe = True\n            \n        return {\n            'safe': safe,\n            'message': message,\n            'risk_level': risk_level,\n            'reasons': reasons\n        }\n        \n    except Exception as e:\n        return {\n            'safe': False,\n            'message': f'Scan error: {str(e)}',\n            'risk_level': 'unknown',\n            'reasons': ['Scanning process encountered an error', 'Unable to complete security analysis', 'Technical issues prevented full assessment']\n        }\n\ndef scan_file_for_malware(file_path):\n    \"\"\"Basic file malware scan using signatures\"\"\"\n    try:\n        reasons = []\n        risk_factors = []\n        \n        # Malware signatures (basic examples)\n        malware_signatures = {\n            b'EICAR-STANDARD-ANTIVIRUS-TEST-FILE': 'EICAR test file signature detected',\n            b'X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR': 'EICAR alternative test signature detected',\n        }\n        \n        # File extension analysis\n        file_ext = os.path.splitext(file_path)[1].lower()\n        \n        # Suspicious file extensions\n        high_risk_extensions = {\n            '.exe': 'Executable file - can run code directly',\n            '.scr': 'Screen saver file - often used to hide malware',\n            '.bat': 'Batch script - can execute system commands',\n            '.cmd': 'Command script - can execute system commands',\n            '.com': 'Command executable - legacy executable format',\n            '.pif': 'Program information file - can execute programs'\n        }\n        \n        medium_risk_extensions = {\n            '.jar': 'Java archive - can contain executable code',\n            '.vbs': 'Visual Basic script - can execute code',\n            '.js': 'JavaScript file - can execute in browsers',\n            '.ps1': 'PowerShell script - can execute system commands',\n            '.msi': 'Windows installer - can install software'\n        }\n        \n        safe_extensions = {\n            '.txt': 'Plain text file - generally safe',\n            '.jpg': 'JPEG image - safe image format',\n            '.png': 'PNG image - safe image format',\n            '.pdf': 'PDF document - generally safe but can contain scripts',\n            '.docx': 'Word document - generally safe but can contain macros',\n            '.xlsx': 'Excel spreadsheet - generally safe but can contain macros'\n        }\n        \n        # Check file extension\n        if file_ext in high_risk_extensions:\n            return {\n                'clean': False,\n                'message': f'Suspicious file extension: {file_ext}',\n                'risk_level': 'high',\n                'reasons': [\n                    high_risk_extensions[file_ext],\n                    'High-risk file types can execute code on your system',\n                    'Only run files from trusted sources',\n                    'Consider scanning with updated antivirus software'\n                ]\n            }\n        elif file_ext in medium_risk_extensions:\n            risk_factors.append(f'{medium_risk_extensions[file_ext]} - exercise caution')\n        elif file_ext in safe_extensions:\n            reasons.append(f'{safe_extensions[file_ext]} - low execution risk')\n        else:\n            risk_factors.append(f'Unknown file extension ({file_ext}) - verify file type')\n        \n        # Read file and check for signatures\n        with open(file_path, 'rb') as f:\n            content = f.read()\n        \n        # Check for malware signatures\n        for signature, description in malware_signatures.items():\n            if signature in content:\n                return {\n                    'clean': False,\n                    'message': 'Known malware signature detected',\n                    'risk_level': 'high',\n                    'reasons': [\n                        description,\n                        'File contains known malicious code patterns',\n                        'Immediately quarantine or delete this file',\n                        'Do not execute or open this file'\n                    ]\n                }\n        \n        # File size analysis\n        file_size = os.path.getsize(file_path)\n        if file_size == 0:\n            risk_factors.append('File is empty - could be corrupted or suspicious')\n        elif file_size > 100 * 1024 * 1024:  # 100MB\n            reasons.append(f'Large file ({file_size // (1024*1024)}MB) - no threats detected')\n            risk_factors.append('Large files may take longer to scan completely')\n        else:\n            reasons.append(f'Normal file size ({file_size} bytes)')\n            \n        # Additional safety checks\n        reasons.extend([\n            'No known malware signatures detected',\n            'File structure appears normal',\n            'Basic content analysis completed'\n        ])\n        \n        if risk_factors:\n            reasons.extend(risk_factors)\n            \n        # Determine final risk level and clean status\n        if len(risk_factors) > 2:\n            final_risk = 'medium'\n            clean = False\n            message = 'Some concerns detected - review file carefully'\n        elif len(risk_factors) > 0:\n            final_risk = 'low'\n            clean = True\n            message = 'No immediate threats but some concerns noted'\n        else:\n            final_risk = 'low'\n            clean = True\n            message = 'No threats detected (basic scan)'\n            \n        return {\n            'clean': clean,\n            'message': message,\n            'risk_level': final_risk,\n            'reasons': reasons\n        }\n        \n    except Exception as e:\n        return {\n            'clean': False,\n            'message': f'Scan error: {str(e)}',\n            'risk_level': 'unknown',\n            'reasons': [\n                'File scanning process encountered an error',\n                'Unable to read or analyze file contents',\n                'Technical issues prevented complete analysis',\n                'Try scanning with alternative antivirus tools'\n            ]\n        }\n\ndef vulnerability_scan(url):\n    \"\"\"Basic vulnerability scan for common web vulnerabilities with SSRF protection\"\"\"\n    try:\n        vulnerabilities = []\n        reasons = []\n        security_issues = []\n        security_strengths = []\n        \n        # SSRF Protection: Validate URL before vulnerability testing\n        ssrf_valid, ssrf_message = validate_url_for_ssrf(url)\n        if not ssrf_valid:\n            return {\n                'vulnerabilities': [f'Security restriction: {ssrf_message}'],\n                'risk_level': 'high',\n                'message': 'URL blocked for security reasons',\n                'reasons': [\n                    'URL points to private or internal network',\n                    'Scanning internal services is prohibited',\n                    'Only public URLs can be vulnerability scanned'\n                ]\n            }\n        \n        # Test for SQL Injection (basic) with SSRF protection\n        sqli_payloads = [\"'\", \"' OR '1'='1\", \"'; DROP TABLE users; --\"]\n        sql_injection_found = False\n        \n        for payload in sqli_payloads:\n            test_url = f\"{url}?id={payload}\"\n            try:\n                # Validate test URL for SSRF\n                test_valid, _ = validate_url_for_ssrf(test_url)\n                if not test_valid:\n                    continue\n                    \n                response = requests.get(test_url, timeout=5, allow_redirects=False)\n                if any(error in response.text.lower() for error in ['sql', 'mysql', 'syntax error', 'database', 'oracle', 'postgresql']):\n                    if not sql_injection_found:  # Only add once\n                        vulnerabilities.append('Potential SQL Injection')\n                        security_issues.append('SQL error messages exposed - indicates possible SQL injection vulnerability')\n                        security_issues.append('Database errors should never be visible to users')\n                        sql_injection_found = True\n                    break\n            except:\n                pass\n        \n        if not sql_injection_found:\n            security_strengths.append('No obvious SQL injection vulnerabilities detected')\n        \n        # Test for XSS (basic) with SSRF protection\n        xss_payload = \"<script>alert('XSS')</script>\"\n        try:\n            test_url = f\"{url}?search={xss_payload}\"\n            test_valid, _ = validate_url_for_ssrf(test_url)\n            if test_valid:\n                response = requests.get(test_url, timeout=5, allow_redirects=False)\n                if xss_payload in response.text:\n                    vulnerabilities.append('Potential Cross-Site Scripting (XSS)')\n                    security_issues.append('Script tags are reflected without sanitization')\n                    security_issues.append('User input is not properly encoded before output')\n                    security_issues.append('XSS can allow attackers to execute malicious scripts')\n                else:\n                    security_strengths.append('Basic XSS payload was properly handled/filtered')\n        except:\n            pass\n        \n        # Check for common security headers with SSRF protection\n        missing_headers = []\n        present_headers = []\n        try:\n            response = requests.head(url, timeout=5, allow_redirects=False)\n            headers = response.headers\n            \n            security_headers_info = {\n                'X-Frame-Options': 'Prevents clickjacking attacks by controlling iframe embedding',\n                'X-XSS-Protection': 'Enables browser XSS filtering (legacy but still useful)',\n                'X-Content-Type-Options': 'Prevents MIME type sniffing attacks',\n                'Strict-Transport-Security': 'Enforces HTTPS connections (HSTS)',\n                'Content-Security-Policy': 'Controls resource loading to prevent XSS',\n                'Referrer-Policy': 'Controls information sent in Referer header'\n            }\n            \n            for header, description in security_headers_info.items():\n                if header in headers:\n                    present_headers.append(f'{header}: {description}')\n                else:\n                    missing_headers.append(f'{header}: {description}')\n            \n            if missing_headers:\n                vulnerabilities.append(f'Missing security headers ({len(missing_headers)} headers)')\n                security_issues.extend([f'Missing {header.split(\":\")[0]}' for header in missing_headers])\n            \n            if present_headers:\n                security_strengths.extend([f'Has {header.split(\":\")[0]}' for header in present_headers])\n                \n        except:\n            security_issues.append('Unable to check security headers - server may be unreachable')\n        \n        # Check HTTPS usage\n        if url.startswith('https://'):\n            security_strengths.append('Uses HTTPS encryption for secure communication')\n        else:\n            security_issues.append('Uses HTTP instead of HTTPS - data transmitted in plain text')\n            vulnerabilities.append('Insecure HTTP connection')\n        \n        # Compile reasons\n        if security_issues:\n            reasons.extend(security_issues)\n        if security_strengths:\n            reasons.extend(security_strengths)\n        \n        # Additional analysis\n        if not vulnerabilities:\n            reasons.append('Basic vulnerability scan completed with no major issues found')\n        else:\n            reasons.append(f'Found {len(vulnerabilities)} potential security vulnerabilities')\n            reasons.append('Consider professional security audit for comprehensive assessment')\n        \n        # Determine risk level based on vulnerabilities and severity\n        if 'SQL Injection' in str(vulnerabilities) or 'XSS' in str(vulnerabilities):\n            risk_level = 'high'\n            reasons.append('Critical vulnerabilities detected - immediate attention required')\n        elif len(vulnerabilities) > 2:\n            risk_level = 'high'\n            reasons.append('Multiple vulnerabilities indicate poor security posture')\n        elif vulnerabilities:\n            risk_level = 'medium'\n            reasons.append('Some vulnerabilities found - should be addressed')\n        else:\n            risk_level = 'low'\n            reasons.append('No obvious vulnerabilities detected in basic scan')\n        \n        return {\n            'vulnerabilities': vulnerabilities,\n            'risk_level': risk_level,\n            'message': f'Found {len(vulnerabilities)} potential security issues' if vulnerabilities else 'No obvious vulnerabilities detected',\n            'reasons': reasons,\n            'security_issues': security_issues,\n            'security_strengths': security_strengths,\n            'missing_headers': missing_headers,\n            'present_headers': present_headers\n        }\n        \n    except Exception as e:\n        return {\n            'vulnerabilities': [],\n            'risk_level': 'unknown',\n            'message': f'Scan error: {str(e)}',\n            'reasons': [\n                'Vulnerability scanning process encountered an error',\n                'Unable to complete security assessment',\n                'Network issues or server problems prevented scan',\n                'Try scanning again or use professional security tools'\n            ]\n        }\n","size_bytes":22211},"static/css/style.css":{"content":"/* Matrix Cybersecurity Theme */\n:root {\n    --bg-primary: #0b0b0b;\n    --bg-secondary: #1a1a1a;\n    --bg-tertiary: #2a2a2a;\n    --accent-green: #00ff66;\n    --accent-green-dim: #00cc52;\n    --text-primary: #ffffff;\n    --text-secondary: #e0e0e0;\n    --text-muted: #b0b0b0;\n    --danger: #ff4444;\n    --warning: #ffaa00;\n    --success: #00ff66;\n    --info: #00aaff;\n}\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    background: var(--bg-primary);\n    color: var(--text-primary);\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    line-height: 1.6;\n    overflow-x: hidden;\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n}\n\n/* Matrix Canvas Background */\n#matrix-canvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: -1;\n    opacity: 0.3;\n}\n\n/* Navigation */\n.navbar {\n    background: rgba(26, 26, 26, 0.95);\n    backdrop-filter: blur(10px);\n    border-bottom: 1px solid var(--accent-green);\n    z-index: 1000;\n}\n\n.navbar-brand {\n    color: var(--accent-green) !important;\n    font-weight: bold;\n    text-shadow: 0 0 10px var(--accent-green);\n}\n\n.navbar-nav .nav-link {\n    color: var(--text-secondary) !important;\n    transition: all 0.3s ease;\n    position: relative;\n}\n\n.navbar-nav .nav-link:hover {\n    color: var(--accent-green) !important;\n    text-shadow: 0 0 8px var(--accent-green);\n}\n\n.navbar-nav .nav-link.active {\n    color: var(--accent-green) !important;\n    background: rgba(0, 255, 102, 0.2);\n    border-radius: 5px;\n    box-shadow: 0 2px 10px rgba(0, 255, 102, 0.3);\n    font-weight: 600;\n}\n\n.dropdown-menu {\n    background: var(--bg-secondary);\n    border: 1px solid var(--accent-green);\n}\n\n.dropdown-item {\n    color: var(--text-primary);\n    transition: all 0.3s ease;\n}\n\n.dropdown-item:hover {\n    background: var(--accent-green);\n    color: var(--bg-primary);\n}\n\n/* Profile Images */\n.profile-img {\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    object-fit: cover;\n    border: 2px solid var(--accent-green);\n}\n\n.profile-img-sm {\n    width: 24px;\n    height: 24px;\n    border-radius: 50%;\n    object-fit: cover;\n}\n\n/* Main Content */\n.main-content {\n    margin-top: 80px;\n    flex: 1 0 auto;\n    padding-bottom: 8rem;\n}\n\n/* Educational Section Spacing */\n.educational-section {\n    margin-bottom: 4rem !important;\n}\n\n/* Service Pages Extra Protection */\n.service-page .main-content {\n    padding-bottom: 10rem !important;\n}\n\n/* Cards */\n.card {\n    background: rgba(26, 26, 26, 0.9);\n    border: 1px solid var(--bg-tertiary);\n    border-radius: 15px;\n    backdrop-filter: blur(10px);\n    transition: all 0.3s ease;\n}\n\n.card:hover {\n    border-color: var(--accent-green);\n    box-shadow: 0 0 20px rgba(0, 255, 102, 0.2);\n    transform: translateY(-2px);\n}\n\n.module-card {\n    height: 100%;\n    border: 1px solid var(--bg-tertiary);\n    background: linear-gradient(135deg, rgba(26, 26, 26, 0.95), rgba(42, 42, 42, 0.95));\n}\n\n.module-card:hover {\n    border-color: var(--accent-green);\n    box-shadow: 0 0 25px rgba(0, 255, 102, 0.3);\n}\n\n.module-header {\n    display: flex;\n    align-items: center;\n    margin-bottom: 1rem;\n}\n\n.module-icon {\n    width: 50px;\n    height: 50px;\n    background: linear-gradient(45deg, var(--accent-green), var(--accent-green-dim));\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-right: 15px;\n    box-shadow: 0 0 15px rgba(0, 255, 102, 0.4);\n}\n\n.module-icon.custom-logo {\n    background: none !important;\n    box-shadow: none !important;\n    border-radius: 0 !important;\n    position: relative;\n}\n\n.module-icon i {\n    font-size: 20px;\n    color: #1a1a1a;\n}\n\n/* Large Module Icons for Overview */\n.module-icon-large {\n    width: 80px;\n    height: 80px;\n    background: linear-gradient(45deg, var(--accent-green), var(--accent-green-dim));\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 0 auto 20px;\n    box-shadow: 0 0 20px rgba(0, 255, 102, 0.4);\n}\n\n/* Custom logo container - no default background */\n.module-icon-large.custom-logo {\n    background: none !important;\n    box-shadow: none !important;\n    border-radius: 0 !important;\n    position: relative;\n}\n\n.module-icon-large.custom-logo .service-logo-hash,\n.module-icon-large.custom-logo .service-logo-lock,\n.module-icon-large.custom-logo .service-logo-search,\n.module-icon-large.custom-logo .service-logo-hammer,\n.module-icon-large.custom-logo .service-logo-scale,\n.module-icon-large.custom-logo .service-logo-globe,\n.module-icon-large.custom-logo .service-logo-key,\n.module-icon-large.custom-logo .service-logo-network {\n    margin: 0 !important;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n\n.module-icon.custom-logo .service-logo-hash,\n.module-icon.custom-logo .service-logo-lock,\n.module-icon.custom-logo .service-logo-search,\n.module-icon.custom-logo .service-logo-hammer,\n.module-icon.custom-logo .service-logo-scale,\n.module-icon.custom-logo .service-logo-globe,\n.module-icon.custom-logo .service-logo-key,\n.module-icon.custom-logo .service-logo-network {\n    margin: 0 !important;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n\n.module-icon-large i {\n    font-size: 30px;\n    color: #1a1a1a;\n}\n\n/* Overview Cards */\n.overview-card {\n    min-height: 280px;\n    display: flex;\n    flex-direction: column;\n}\n\n.overview-card .card-body {\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    padding: 2rem;\n}\n\n.overview-card .card-title {\n    font-size: 1.25rem;\n    margin-bottom: 15px;\n}\n\n.overview-card .card-text {\n    color: var(--text-secondary);\n    margin-bottom: 20px;\n    flex-grow: 1;\n}\n\n.card-title {\n    color: var(--accent-green) !important;\n    margin: 0;\n    font-weight: 600;\n}\n\n/* Service card title visibility fixes */\n.module-card .card-title,\n.overview-card .card-title {\n    color: var(--text-primary) !important;\n    font-weight: 600;\n    margin-bottom: 1rem;\n}\n\n/* Ensure card titles are always visible */\nh1.card-title, h2.card-title, h3.card-title, h4.card-title, h5.card-title, h6.card-title {\n    color: var(--text-primary) !important;\n}\n\n.education-info {\n    background: rgba(0, 255, 102, 0.1);\n    border: 1px solid rgba(0, 255, 102, 0.3);\n    border-radius: 8px;\n    padding: 10px;\n    margin-bottom: 1rem;\n}\n\n/* Buttons */\n.btn {\n    border-radius: 8px;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    border: none;\n    position: relative;\n    overflow: hidden;\n}\n\n.btn-glow {\n    box-shadow: 0 0 15px rgba(0, 255, 102, 0.3);\n}\n\n.btn-glow:hover {\n    box-shadow: 0 0 25px rgba(0, 255, 102, 0.6);\n    transform: translateY(-1px);\n}\n\n.btn-primary {\n    background: linear-gradient(45deg, var(--accent-green), var(--accent-green-dim));\n    color: var(--bg-primary);\n}\n\n.btn-primary:hover {\n    background: linear-gradient(45deg, var(--accent-green-dim), var(--accent-green));\n    color: var(--bg-primary);\n}\n\n.btn-success {\n    background: linear-gradient(45deg, #28a745, #20c997);\n}\n\n.btn-warning {\n    background: linear-gradient(45deg, #ffc107, #fd7e14);\n    color: var(--bg-primary);\n}\n\n.btn-danger {\n    background: linear-gradient(45deg, #dc3545, #e74c3c);\n}\n\n.btn-info {\n    background: linear-gradient(45deg, #17a2b8, #6f42c1);\n}\n\n.btn-dark {\n    background: linear-gradient(45deg, #343a40, #495057);\n}\n\n.btn-outline-primary {\n    border: 2px solid var(--accent-green);\n    color: var(--accent-green);\n    background: transparent;\n}\n\n.btn-outline-primary:hover {\n    background: var(--accent-green);\n    color: var(--bg-primary);\n}\n\n/* Forms */\n.form-control, .form-select {\n    background: rgba(42, 42, 42, 0.8);\n    border: 1px solid var(--bg-tertiary);\n    color: var(--text-primary);\n    border-radius: 8px;\n    transition: all 0.3s ease;\n}\n\n.form-control:focus, .form-select:focus {\n    background: rgba(42, 42, 42, 0.9);\n    border-color: var(--accent-green);\n    box-shadow: 0 0 10px rgba(0, 255, 102, 0.2);\n    color: var(--text-primary);\n}\n\n.form-label {\n    color: var(--text-secondary);\n    font-weight: 500;\n    margin-bottom: 5px;\n}\n\n.form-text {\n    color: var(--text-secondary);\n    font-size: 0.875rem;\n}\n\n/* Text Overrides for Better Readability */\n.text-muted {\n    color: var(--text-muted) !important;\n}\n\nsmall {\n    color: var(--text-secondary) !important;\n}\n\n.d-block.text-muted,\n.form-text {\n    color: var(--text-secondary) !important;\n}\n\n/* Additional text color fixes */\n.card-text {\n    color: var(--text-secondary) !important;\n}\n\n.text-center.text-muted {\n    color: var(--text-secondary) !important;\n}\n\n.badge {\n    font-weight: 500;\n}\n\n/* Footer text */\nfooter small {\n    color: var(--text-secondary) !important;\n}\n\n/* Activity details */\n.activity-details small {\n    color: var(--text-secondary) !important;\n}\n\n/* Comprehensive text visibility fixes */\np, span, div, small, li, td, th, label, h1, h2, h3, h4, h5, h6 {\n    color: inherit;\n}\n\n/* Ensure all text elements have proper contrast */\n.text-muted, .text-secondary {\n    color: var(--text-muted) !important;\n}\n\n.form-text, small.form-text {\n    color: var(--text-secondary) !important;\n}\n\n/* Fix any potential Bootstrap overrides */\n.text-dark {\n    color: var(--text-primary) !important;\n}\n\n/* Ensure tab content text is visible */\n.tab-content, .tab-pane {\n    color: var(--text-primary);\n}\n\n.tab-content p, .tab-content div, .tab-content span, .tab-content label {\n    color: var(--text-secondary);\n}\n\n/* Modal text visibility */\n.modal-body, .modal-header, .modal-footer {\n    color: var(--text-primary);\n}\n\n.modal-body p, .modal-body div, .modal-body span, .modal-body small,\n.modal-body label, .modal-body li {\n    color: var(--text-secondary) !important;\n}\n\n/* Service page text visibility */\n.service-description, .info-card p, .info-card li {\n    color: var(--text-secondary) !important;\n}\n\n/* Form element text visibility fixes */\n.form-label {\n    color: var(--text-primary) !important;\n}\n\n.form-check-label {\n    color: var(--text-primary) !important;\n}\n\n.form-check-input + .form-check-label {\n    color: var(--text-primary) !important;\n}\n\n/* Info card comprehensive text fixes */\n.info-card {\n    color: var(--text-primary) !important;\n}\n\n.info-card h5, .info-card h6 {\n    color: var(--accent-green) !important;\n}\n\n.info-card p, .info-card li, .info-card ul, .info-card ol {\n    color: var(--text-secondary) !important;\n}\n\n.info-card strong {\n    color: var(--text-primary) !important;\n}\n\n/* Radio button and checkbox labels */\ninput[type=\"radio\"] + label,\ninput[type=\"checkbox\"] + label,\n.form-check label {\n    color: var(--text-primary) !important;\n}\n\n/* Ensure all form elements have proper text color */\n.form-control, .form-select, .form-control:focus, .form-select:focus {\n    color: var(--text-primary) !important;\n}\n\n/* Placeholder text */\n.form-control::placeholder, .form-control::-webkit-input-placeholder {\n    color: var(--text-muted) !important;\n}\n\n/* Additional button text fixes */\n.btn {\n    color: inherit;\n}\n\n.btn-primary {\n    color: var(--bg-primary) !important;\n}\n\n.btn-outline-primary {\n    color: var(--accent-green) !important;\n}\n\n/* Comprehensive text inheritance fixes */\n* {\n    color: inherit;\n}\n\n/* Override any problematic Bootstrap defaults */\n.card *, .card-body *, .module-card * {\n    color: inherit;\n}\n\n/* File input styling and text visibility */\ninput[type=\"file\"] {\n    color: var(--text-primary) !important;\n    background: rgba(42, 42, 42, 0.8) !important;\n    border: 1px solid var(--bg-tertiary) !important;\n    border-radius: 8px !important;\n    padding: 8px 12px !important;\n}\n\ninput[type=\"file\"]::file-selector-button {\n    background: var(--accent-green) !important;\n    color: var(--bg-primary) !important;\n    border: none !important;\n    border-radius: 5px !important;\n    padding: 6px 12px !important;\n    margin-right: 10px !important;\n}\n\ninput[type=\"file\"]::-webkit-file-upload-button {\n    background: var(--accent-green) !important;\n    color: var(--bg-primary) !important;\n    border: none !important;\n    border-radius: 5px !important;\n    padding: 6px 12px !important;\n    margin-right: 10px !important;\n}\n\n/* Password strength text visibility */\n.password-strength,\n.strength-indicator,\n.strength-text {\n    color: var(--text-secondary) !important;\n}\n\n/* Alert text visibility */\n.alert strong,\n.alert p,\n.alert span,\n.alert div {\n    color: inherit !important;\n}\n\n/* Card header text */\n.card-header,\n.card-header h5,\n.card-header h6 {\n    color: var(--text-primary) !important;\n}\n\n/* Security notice and warning text */\n.alert-warning {\n    color: var(--warning) !important;\n}\n\n.alert-warning strong {\n    color: var(--warning) !important;\n}\n\n/* List items in info cards */\n.module-card ul li,\n.module-card ol li {\n    color: var(--text-secondary) !important;\n}\n\n/* Form group labels and help text */\n.form-group label,\n.mb-3 label,\n.form-label {\n    color: var(--text-primary) !important;\n    font-weight: 500;\n}\n\n/* File input \"No file chosen\" text fix */\ninput[type=\"file\"]:not(:valid) {\n    color: var(--text-muted) !important;\n}\n\n/* Ensure all interactive elements have proper contrast */\n.btn-success {\n    color: var(--bg-primary) !important;\n}\n\n.btn-warning {\n    color: var(--bg-primary) !important;\n}\n\n/* URL Scanner and scanning features text visibility */\n.scanning-features,\n.security-tips,\n.feature-list {\n    color: var(--text-secondary) !important;\n}\n\n.scanning-features ul li,\n.security-tips ul li,\n.feature-list li {\n    color: var(--text-secondary) !important;\n    margin-bottom: 8px;\n}\n\n.scanning-features h6,\n.security-tips h6,\n.feature-section h6 {\n    color: var(--text-primary) !important;\n}\n\n/* Scanner result text */\n.scan-result,\n.scan-status,\n.scan-details {\n    color: var(--text-primary) !important;\n}\n\n/* URL input and form help text */\n.form-text.text-muted,\nsmall.text-muted {\n    color: var(--text-muted) !important;\n}\n\n/* Warning and info boxes */\n.info-box,\n.warning-box,\n.tips-box {\n    color: var(--text-secondary) !important;\n}\n\n.info-box h6,\n.warning-box h6,\n.tips-box h6 {\n    color: var(--text-primary) !important;\n}\n\n/* Scanner icons and text combinations */\n.scanner-icon + span,\n.feature-icon + span {\n    color: var(--text-secondary) !important;\n}\n\n/* File size limits and restrictions text */\n.file-restrictions,\n.size-limit,\n.format-info {\n    color: var(--text-muted) !important;\n}\n\n/* Security recommendation text */\n.security-recommendations li,\n.safety-tips li,\n.best-practices li {\n    color: var(--text-secondary) !important;\n}\n\n/* URL placeholder and input text */\n.form-control::-webkit-input-placeholder {\n    color: var(--text-muted) !important;\n    opacity: 0.7;\n}\n\n.form-control::-moz-placeholder {\n    color: var(--text-muted) !important;\n    opacity: 0.7;\n}\n\n.form-control:-ms-input-placeholder {\n    color: var(--text-muted) !important;\n    opacity: 0.7;\n}\n\n/* Ensure bullet points and list indicators are visible */\nul li::marker {\n    color: var(--accent-green) !important;\n}\n\nol li::marker {\n    color: var(--accent-green) !important;\n}\n\n/* Specific fixes for URL scanner lists and small text */\n.list-unstyled li,\n.small,\n.text-start li {\n    color: var(--text-secondary) !important;\n}\n\n/* Small text in card bodies */\n.card-body .small,\n.card-body small,\n.p-3 .small {\n    color: var(--text-secondary) !important;\n}\n\n/* Text-start lists */\n.text-start ul li,\n.text-start ol li {\n    color: var(--text-secondary) !important;\n}\n\n/* Any remaining invisible text fixes */\nspan, div, p {\n    color: inherit;\n}\n\n/* Specific list item visibility fixes */\n.card-body li,\n.module-card li {\n    color: var(--text-secondary) !important;\n}\n\n/* Security tips and recommendations - force visibility */\n.card-body ul li,\n.card-body ol li,\n.module-card ul li,\n.module-card ol li {\n    color: var(--text-secondary) !important;\n}\n\n/* All unstyled lists */\n.list-unstyled li {\n    color: var(--text-secondary) !important;\n}\n\n/* Force all small text to be visible */\n.small {\n    color: var(--text-secondary) !important;\n}\n\n/* Text in paragraphs within cards */\n.card p,\n.module-card p {\n    color: var(--text-secondary) !important;\n}\n\n/* Specific scanner check lists */\n.mt-3 ul li,\n.security-tips ul li,\n.best-practices ul li {\n    color: var(--text-secondary) !important;\n}\n\n/* Override any Bootstrap text utilities that might hide text */\n.text-muted,\n.text-secondary,\n.text-dark {\n    color: var(--text-secondary) !important;\n}\n\n/* Targeted text visibility fixes without breaking existing styles */\n\n/* Fix invisible list items in scanner sections */\n.card-body .list-unstyled li,\n.card-body .mt-3 ul li,\n.card-body .small,\n.card-body small.text-start li {\n    color: var(--text-secondary) !important;\n}\n\n/* Fix invisible text in security tips sections */\n.text-center.p-3 ul li,\n.text-center.p-3 .small,\n.p-3.text-start ul li {\n    color: var(--text-secondary) !important;\n}\n\n/* Fix any remaining invisible help text */\n.form-text.text-muted,\nsmall.text-muted,\n.text-muted.small {\n    color: var(--text-muted) !important;\n}\n\n/* Fix invisible text in scanner feature lists */\n.mt-3 h6 + ul li,\n.card-body h6 + ul li {\n    color: var(--text-secondary) !important;\n}\n\n/* Comprehensive text visibility fix for all remaining elements */\n.card-body ul li,\n.card-body ol li,\n.module-card ul li,\n.module-card ol li,\n.list-unstyled li,\n.small,\nsmall {\n    color: var(--text-secondary) !important;\n}\n\n/* Security best practices text */\n.text-center.p-3 li,\n.text-start li,\n.p-3 li {\n    color: var(--text-secondary) !important;\n}\n\n/* Any text within cards that might be invisible */\n.card p,\n.card span,\n.card div:not(.alert):not(.btn):not(.badge) {\n    color: var(--text-secondary) !important;\n}\n\n/* Form elements and help text */\n.form-text,\n.help-text {\n    color: var(--text-muted) !important;\n}\n\n/* Alerts */\n.alert {\n    border-radius: 10px;\n    border: none;\n    backdrop-filter: blur(10px);\n}\n\n.alert-sm {\n    padding: 8px 12px;\n    font-size: 0.875rem;\n}\n\n.alert-success {\n    background: rgba(0, 255, 102, 0.1);\n    color: var(--accent-green);\n    border: 1px solid rgba(0, 255, 102, 0.3);\n}\n\n.alert-warning {\n    background: rgba(255, 170, 0, 0.1);\n    color: #ffaa00;\n    border: 1px solid rgba(255, 170, 0, 0.3);\n}\n\n.alert-danger {\n    background: rgba(255, 68, 68, 0.1);\n    color: #ff4444;\n    border: 1px solid rgba(255, 68, 68, 0.3);\n}\n\n.alert-info {\n    background: rgba(0, 170, 255, 0.1);\n    color: #00aaff;\n    border: 1px solid rgba(0, 170, 255, 0.3);\n}\n\n/* Hero Section */\n.hero-section {\n    min-height: 100vh;\n    display: flex;\n    align-items: center;\n}\n\n.hero-content {\n    z-index: 2;\n}\n\n.hero-title {\n    font-size: 3.5rem;\n    font-weight: 700;\n    color: var(--accent-green);\n    text-shadow: 0 0 20px rgba(0, 255, 102, 0.5);\n    margin-bottom: 1rem;\n}\n\n.hero-subtitle {\n    font-size: 1.25rem;\n    color: var(--text-secondary);\n    margin-bottom: 2rem;\n    line-height: 1.6;\n}\n\n.hero-features {\n    margin: 2rem 0;\n}\n\n.feature-item {\n    display: flex;\n    align-items: center;\n    margin-bottom: 1rem;\n    color: var(--text-secondary);\n}\n\n.feature-item i {\n    color: var(--accent-green);\n    margin-right: 15px;\n    width: 20px;\n}\n\n.hero-cta {\n    margin-top: 2rem;\n}\n\n.hero-visual {\n    text-align: center;\n}\n\n.security-grid {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 20px;\n    margin-top: 50px;\n}\n\n.security-item {\n    background: rgba(26, 26, 26, 0.8);\n    border: 1px solid var(--bg-tertiary);\n    border-radius: 15px;\n    padding: 30px 20px;\n    text-align: center;\n    transition: all 0.3s ease;\n}\n\n.security-item:hover {\n    border-color: var(--accent-green);\n    box-shadow: 0 0 20px rgba(0, 255, 102, 0.2);\n    transform: translateY(-5px);\n}\n\n.security-item i {\n    font-size: 2rem;\n    color: var(--accent-green);\n    margin-bottom: 15px;\n    display: block;\n}\n\n.security-item h6 {\n    color: var(--text-primary);\n    margin: 0;\n}\n\n/* Welcome Card */\n.welcome-card {\n    background: linear-gradient(135deg, rgba(0, 255, 102, 0.1), rgba(0, 204, 82, 0.1));\n    border: 1px solid rgba(0, 255, 102, 0.3);\n    border-radius: 15px;\n    padding: 2rem;\n    text-align: center;\n    margin-bottom: 2rem;\n}\n\n.welcome-card h2 {\n    color: var(--accent-green);\n    margin-bottom: 0.5rem;\n}\n\n.welcome-card p {\n    color: var(--text-secondary);\n    margin: 0;\n}\n\n/* Activity Cards */\n.activity-card .card-header {\n    background: rgba(0, 255, 102, 0.1);\n    border-bottom: 1px solid rgba(0, 255, 102, 0.3);\n    border-radius: 15px 15px 0 0;\n}\n\n.activity-list {\n    max-height: 300px;\n    overflow-y: auto;\n}\n\n.activity-item {\n    display: flex;\n    align-items: center;\n    padding: 15px 0;\n    border-bottom: 1px solid var(--bg-tertiary);\n}\n\n.activity-item:last-child {\n    border-bottom: none;\n}\n\n.activity-icon {\n    width: 40px;\n    height: 40px;\n    background: var(--bg-tertiary);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-right: 15px;\n    color: var(--accent-green);\n}\n\n.activity-details {\n    flex: 1;\n}\n\n.activity-details strong {\n    color: #ffffff !important;\n    display: block;\n    font-weight: 600;\n}\n\n.activity-details small {\n    color: #e0e0e0 !important;\n}\n\n/* Additional contrast improvements for activity sections */\n.activity-item .activity-details .text-muted,\n.activity-item .text-muted {\n    color: #d0d0d0 !important;\n}\n\n.activity-item .badge {\n    font-weight: 600;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n/* Statistics Cards */\n.stat-card {\n    background: linear-gradient(135deg, rgba(26, 26, 26, 0.95), rgba(42, 42, 42, 0.95));\n    border: 1px solid var(--bg-tertiary);\n    transition: all 0.3s ease;\n}\n\n.stat-card:hover {\n    border-color: var(--accent-green);\n    box-shadow: 0 0 20px rgba(0, 255, 102, 0.2);\n}\n\n.stat-card .card-body {\n    display: flex;\n    align-items: center;\n    padding: 1.5rem;\n}\n\n.stat-icon {\n    width: 60px;\n    height: 60px;\n    background: linear-gradient(45deg, var(--accent-green), var(--accent-green-dim));\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-right: 20px;\n}\n\n.stat-icon i {\n    font-size: 24px;\n    color: var(--bg-primary);\n}\n\n.stat-details h4 {\n    color: var(--accent-green);\n    margin: 0;\n    font-weight: 700;\n    font-size: 2rem;\n}\n\n.stat-details span {\n    color: var(--text-secondary);\n    font-size: 0.9rem;\n}\n\n/* Tables */\n.table-dark {\n    background: rgba(26, 26, 26, 0.8);\n    border: 1px solid var(--bg-tertiary);\n}\n\n.table-dark th {\n    border-color: var(--bg-tertiary);\n    color: var(--accent-green);\n    font-weight: 600;\n}\n\n.table-dark td {\n    border-color: var(--bg-tertiary);\n    color: var(--text-secondary);\n}\n\n.table-striped > tbody > tr:nth-of-type(odd) > td {\n    background: rgba(42, 42, 42, 0.3);\n}\n\n/* Badges */\n.badge {\n    font-weight: 500;\n    padding: 5px 10px;\n}\n\n.bg-success {\n    background: var(--success) !important;\n    color: var(--bg-primary) !important;\n}\n\n.bg-warning {\n    background: var(--warning) !important;\n    color: var(--bg-primary) !important;\n}\n\n.bg-danger {\n    background: var(--danger) !important;\n}\n\n.bg-info {\n    background: var(--info) !important;\n}\n\n.bg-primary {\n    background: var(--accent-green) !important;\n    color: var(--bg-primary) !important;\n}\n\n/* Education Section */\n.education-section {\n    background: rgba(26, 26, 26, 0.5);\n    backdrop-filter: blur(10px);\n}\n\n.section-title {\n    color: var(--accent-green);\n    font-weight: 700;\n    text-shadow: 0 0 15px rgba(0, 255, 102, 0.3);\n}\n\n/* Disclaimer Section */\n.disclaimer-section {\n    background: rgba(255, 170, 0, 0.05);\n    border-top: 1px solid rgba(255, 170, 0, 0.2);\n}\n\n/* Error Pages */\n.error-card, .login-card {\n    background: rgba(26, 26, 26, 0.95);\n    border: 1px solid var(--accent-green);\n    box-shadow: 0 0 30px rgba(0, 255, 102, 0.2);\n}\n\n.error-icon, .login-icon {\n    width: 80px;\n    height: 80px;\n    background: linear-gradient(45deg, var(--accent-green), var(--accent-green-dim));\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 0 auto 20px;\n}\n\n.error-icon i, .login-icon i {\n    font-size: 2rem;\n    color: var(--bg-primary);\n}\n\n.error-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: center;\n    flex-wrap: wrap;\n}\n\n/* Footer */\n.footer {\n    background: rgba(26, 26, 26, 0.95);\n    border-top: 1px solid var(--accent-green);\n    padding: 2rem 0 1.5rem;\n    backdrop-filter: blur(10px);\n    margin-top: auto;\n    position: static;\n    bottom: auto;\n    left: auto;\n    right: auto;\n    z-index: 0;\n}\n\n/* About Page Professional Styling */\n.stats-row .stat-item {\n    text-align: center;\n    padding: 15px;\n}\n\n.stats-row .stat-number {\n    color: var(--accent-green);\n    font-size: 2.5rem;\n    font-weight: 700;\n    margin-bottom: 5px;\n}\n\n.stats-row .stat-label {\n    color: var(--text-secondary);\n    font-size: 0.9rem;\n    margin-bottom: 0;\n}\n\n.company-overview-card {\n    background: var(--bg-secondary);\n    border: 1px solid var(--accent-green);\n}\n\n.company-highlights .highlight-item {\n    display: flex;\n    align-items: center;\n    margin-bottom: 20px;\n    padding: 15px;\n    border-radius: 8px;\n    background: rgba(0, 255, 102, 0.1);\n}\n\n.company-highlights .highlight-item i {\n    font-size: 2rem;\n    color: var(--accent-green);\n    margin-right: 15px;\n    min-width: 40px;\n}\n\n.company-highlights .highlight-item h5 {\n    color: var(--text-primary);\n    margin-bottom: 5px;\n}\n\n.company-highlights .highlight-item p {\n    color: var(--text-secondary);\n    margin-bottom: 0;\n    font-size: 0.9rem;\n}\n\n.mission-vision-card {\n    background: var(--bg-secondary);\n    border: 1px solid var(--accent-green);\n    transition: all 0.3s ease;\n}\n\n.mission-vision-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 10px 30px rgba(0, 255, 102, 0.2);\n}\n\n.mv-icon {\n    font-size: 3rem;\n    color: var(--accent-green);\n    margin-bottom: 20px;\n}\n\n.mv-text {\n    font-size: 1rem;\n    line-height: 1.6;\n    color: var(--text-secondary);\n}\n\n.client-card {\n    background: var(--bg-secondary);\n    border: 1px solid var(--accent-green);\n    transition: all 0.3s ease;\n}\n\n.client-card:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 8px 25px rgba(0, 255, 102, 0.15);\n}\n\n.client-icon {\n    font-size: 2.5rem;\n    color: var(--accent-green);\n    margin-bottom: 15px;\n}\n\n.client-stats {\n    margin-top: 15px;\n}\n\n.client-stats .badge {\n    font-size: 0.8rem;\n    padding: 8px 12px;\n}\n\n.partnership-card, .contact-card {\n    background: var(--bg-secondary);\n    border: 1px solid var(--accent-green);\n}\n\n.partnership-list {\n    list-style: none;\n    padding: 0;\n}\n\n.partnership-list li {\n    margin-bottom: 10px;\n    font-size: 0.95rem;\n}\n\n.partnership-list li i {\n    margin-right: 10px;\n}\n\n.contact-info .contact-item {\n    display: flex;\n    align-items: center;\n    margin-bottom: 15px;\n    padding: 10px;\n    border-radius: 5px;\n    background: rgba(0, 255, 102, 0.05);\n}\n\n.contact-info .contact-item i {\n    color: var(--accent-green);\n    margin-right: 15px;\n    min-width: 20px;\n}\n\n.cta-trust-indicators {\n    border-top: 1px solid rgba(0, 255, 102, 0.2);\n    padding-top: 20px;\n}\n\n.cta-trust-indicators small {\n    display: block;\n    margin-bottom: 5px;\n}\n\n.cta-trust-indicators i {\n    color: var(--accent-green);\n    margin-right: 5px;\n}\n\n/* Analytics Dashboard Styles */\n.analytics-card {\n    background: rgba(26, 26, 26, 0.95);\n    border: 1px solid var(--accent-green);\n    color: var(--text-light);\n    transition: all 0.3s ease;\n}\n\n.analytics-card:hover {\n    border-color: var(--accent-green);\n    box-shadow: 0 5px 15px rgba(0, 255, 102, 0.3);\n    transform: translateY(-2px);\n}\n\n.analytics-card .card-header {\n    background: rgba(0, 255, 102, 0.1);\n    border-bottom: 1px solid var(--accent-green);\n    color: var(--accent-green);\n    font-weight: 600;\n}\n\n/* Service Ranking Styles */\n.service-rank-item {\n    display: flex;\n    align-items: center;\n    padding: 10px 0;\n    border-bottom: 1px solid rgba(0, 255, 102, 0.2);\n}\n\n.service-rank-item:last-child {\n    border-bottom: none;\n}\n\n.rank-number {\n    background: var(--accent-green);\n    color: var(--bg-primary);\n    width: 25px;\n    height: 25px;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: bold;\n    font-size: 12px;\n    margin-right: 10px;\n}\n\n.rank-icon {\n    color: var(--accent-green);\n    margin-right: 10px;\n    width: 20px;\n}\n\n.rank-name {\n    flex: 1;\n    color: var(--text-light);\n    font-weight: 500;\n}\n\n.rank-count {\n    color: var(--text-muted);\n    font-size: 0.9em;\n}\n\n/* Statistics Items */\n.stat-item {\n    text-align: center;\n    padding: 10px 0;\n}\n\n.stat-number {\n    font-size: 2rem;\n    font-weight: bold;\n    margin: 0;\n    background: linear-gradient(45deg, var(--accent-green), #00cc66);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n/* Chart container styling */\ncanvas {\n    max-width: 100% !important;\n    height: auto !important;\n}\n\n.footer h5, .footer h6 {\n    color: var(--accent-green);\n}\n\n.footer p {\n    color: var(--text-secondary);\n}\n\n.social-links {\n    display: flex;\n    gap: 15px;\n}\n\n.social-link {\n    width: 40px;\n    height: 40px;\n    background: var(--bg-tertiary);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: var(--text-secondary);\n    text-decoration: none;\n    transition: all 0.3s ease;\n}\n\n.social-link:hover {\n    background: var(--accent-green);\n    color: var(--bg-primary);\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(0, 255, 102, 0.3);\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .hero-title {\n        font-size: 2.5rem;\n    }\n    \n    .hero-subtitle {\n        font-size: 1.1rem;\n    }\n    \n    .security-grid {\n        grid-template-columns: 1fr;\n        gap: 15px;\n    }\n    \n    .stat-card .card-body {\n        flex-direction: column;\n        text-align: center;\n    }\n    \n    .stat-icon {\n        margin-right: 0;\n        margin-bottom: 15px;\n    }\n    \n    .error-actions {\n        flex-direction: column;\n    }\n    \n    .error-actions .btn {\n        width: 100%;\n    }\n}\n\n@media (max-width: 576px) {\n    .hero-title {\n        font-size: 2rem;\n    }\n    \n    .module-header {\n        flex-direction: column;\n        text-align: center;\n    }\n    \n    .module-icon {\n        margin-right: 0;\n        margin-bottom: 15px;\n    }\n}\n\n/* Scrollbar Styling */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--bg-secondary);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--accent-green);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--accent-green-dim);\n}\n\n/* Custom scrollbar for activity lists */\n.activity-list::-webkit-scrollbar {\n    width: 6px;\n}\n\n.activity-list::-webkit-scrollbar-track {\n    background: var(--bg-tertiary);\n    border-radius: 3px;\n}\n\n.activity-list::-webkit-scrollbar-thumb {\n    background: var(--accent-green);\n    border-radius: 3px;\n}\n\n/* Loading states */\n.loading {\n    opacity: 0.6;\n    pointer-events: none;\n}\n\n.spinner-border-sm {\n    width: 1rem;\n    height: 1rem;\n}\n\n/* Animations */\n@keyframes glow {\n    0% { box-shadow: 0 0 5px rgba(0, 255, 102, 0.2); }\n    50% { box-shadow: 0 0 20px rgba(0, 255, 102, 0.6); }\n    100% { box-shadow: 0 0 5px rgba(0, 255, 102, 0.2); }\n}\n\n.pulse-glow {\n    animation: glow 2s infinite;\n}\n\n/* Print styles */\n@media print {\n    #matrix-canvas,\n    .navbar,\n    .footer,\n    .btn {\n        display: none !important;\n    }\n    \n    body {\n        background: white;\n        color: black;\n    }\n    \n    .card {\n        border: 1px solid #ccc;\n        box-shadow: none;\n    }\n}\n\n/* Services and About Page Styles */\n.page-header {\n    margin-top: 2rem;\n    margin-bottom: 3rem;\n}\n\n.page-header h1 {\n    color: var(--accent-green);\n    text-shadow: 0 0 20px rgba(0, 255, 102, 0.5);\n}\n\n.service-category-card, .feature-highlight-card, .guarantee-card,\n.mission-card, .feature-card, .value-card, .tech-stack-card,\n.audience-card, .cta-card {\n    background: rgba(0, 255, 102, 0.1);\n    border: 1px solid var(--accent-green);\n    border-radius: 15px;\n    transition: all 0.3s ease;\n    height: 100%;\n}\n\n.service-category-card:hover, .feature-card:hover, .value-card:hover,\n.audience-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 10px 30px rgba(0, 255, 102, 0.3);\n}\n\n.service-header {\n    display: flex;\n    align-items: center;\n    margin-bottom: 1.5rem;\n}\n\n.service-icon {\n    font-size: 2.5rem;\n    color: var(--accent-green);\n    margin-right: 1rem;\n    text-shadow: 0 0 10px rgba(0, 255, 102, 0.8);\n}\n\n.service-item {\n    display: flex;\n    align-items: flex-start;\n    margin-bottom: 2rem;\n    padding: 1rem;\n    background: rgba(0, 0, 0, 0.3);\n    border-radius: 8px;\n    border-left: 3px solid var(--accent-green);\n}\n\n.service-item-icon {\n    font-size: 1.5rem;\n    color: var(--accent-green);\n    margin-right: 1rem;\n    margin-top: 0.25rem;\n    min-width: 2rem;\n}\n\n.service-item-content h5 {\n    color: var(--accent-green);\n    margin-bottom: 0.5rem;\n}\n\n.feature-list {\n    list-style: none;\n    padding-left: 0;\n    margin-top: 0.5rem;\n}\n\n.feature-list li {\n    position: relative;\n    padding-left: 1.5rem;\n    margin-bottom: 0.25rem;\n    color: var(--text-secondary);\n}\n\n.feature-list li:before {\n    content: \"â–¶\";\n    color: var(--accent-green);\n    position: absolute;\n    left: 0;\n    top: 0;\n}\n\n.feature-highlight, .tech-item {\n    text-align: center;\n    padding: 1rem;\n}\n\n.feature-highlight i, .tech-item i {\n    font-size: 2rem;\n    color: var(--accent-green);\n    margin-bottom: 0.5rem;\n    text-shadow: 0 0 10px rgba(0, 255, 102, 0.8);\n}\n\n.feature-highlight h5, .tech-item h5 {\n    color: var(--accent-green);\n    margin-bottom: 0.5rem;\n}\n\n.feature-highlight p, .tech-item p {\n    color: var(--text-secondary);\n    font-size: 0.9rem;\n    line-height: 1.4;\n}\n\n.guarantee-item {\n    padding: 1rem;\n}\n\n.guarantee-item i {\n    font-size: 2rem;\n    color: #ffc107;\n    margin-bottom: 0.5rem;\n    text-shadow: 0 0 10px rgba(255, 193, 7, 0.8);\n}\n\n.guarantee-item h5 {\n    color: #ffc107;\n    margin-bottom: 0.5rem;\n}\n\n.guarantee-item p {\n    color: var(--text-secondary);\n    font-size: 0.9rem;\n    line-height: 1.4;\n}\n\n.mission-icon, .feature-icon, .value-icon, .audience-icon {\n    font-size: 3rem;\n    color: var(--accent-green);\n    margin-bottom: 1rem;\n    text-shadow: 0 0 15px rgba(0, 255, 102, 0.8);\n}\n\n.mission-text {\n    font-size: 1.1rem;\n    line-height: 1.6;\n    color: var(--text-secondary);\n}\n\n.cta-text {\n    font-size: 1.1rem;\n    margin-bottom: 2rem;\n    color: var(--text-secondary);\n}\n\n.cta-buttons {\n    margin-top: 1.5rem;\n}\n\n.text-gradient {\n    background: linear-gradient(45deg, var(--accent-green), #00cc55);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n/* Responsive adjustments for services/about pages */\n@media (max-width: 768px) {\n    .service-item {\n        flex-direction: column;\n        text-align: center;\n    }\n    \n    .service-item-icon {\n        margin-right: 0;\n        margin-bottom: 0.5rem;\n    }\n    \n    .cta-buttons .btn {\n        display: block;\n        width: 100%;\n        margin: 0.5rem 0;\n    }\n}\n","size_bytes":35413},"static/js/app.js":{"content":"// Main Application JavaScript\ndocument.addEventListener('DOMContentLoaded', function() {\n    \n    // Initialize tooltips if Bootstrap is available\n    if (typeof bootstrap !== 'undefined') {\n        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'));\n        var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {\n            return new bootstrap.Tooltip(tooltipTriggerEl);\n        });\n    }\n    \n    // File input styling enhancement\n    const fileInputs = document.querySelectorAll('input[type=\"file\"]');\n    fileInputs.forEach(input => {\n        input.addEventListener('change', function(e) {\n            const fileName = e.target.files[0]?.name || 'Choose file...';\n            const label = e.target.parentNode.querySelector('.file-label');\n            if (label) {\n                label.textContent = fileName;\n            }\n        });\n    });\n    \n    // Form validation enhancement\n    const forms = document.querySelectorAll('form');\n    forms.forEach(form => {\n        form.addEventListener('submit', function(e) {\n            const submitBtn = form.querySelector('button[type=\"submit\"]');\n            if (submitBtn) {\n                submitBtn.classList.add('loading');\n                submitBtn.disabled = true;\n                \n                // Re-enable after 5 seconds as fallback\n                setTimeout(() => {\n                    submitBtn.classList.remove('loading');\n                    submitBtn.disabled = false;\n                }, 5000);\n            }\n        });\n    });\n    \n    // Smooth scroll for anchor links\n    const anchorLinks = document.querySelectorAll('a[href^=\"#\"]');\n    anchorLinks.forEach(link => {\n        link.addEventListener('click', function(e) {\n            const href = this.getAttribute('href');\n            // Skip empty hash or just \"#\"\n            if (!href || href === '#' || href.length <= 1) {\n                return;\n            }\n            \n            e.preventDefault();\n            const target = document.querySelector(href);\n            if (target) {\n                target.scrollIntoView({\n                    behavior: 'smooth',\n                    block: 'start'\n                });\n            }\n        });\n    });\n    \n    // Auto-hide alerts after 5 seconds\n    const alerts = document.querySelectorAll('.alert:not(.alert-permanent)');\n    alerts.forEach(alert => {\n        setTimeout(() => {\n            if (alert.parentNode) {\n                alert.style.opacity = '0';\n                alert.style.transform = 'translateY(-20px)';\n                setTimeout(() => {\n                    if (alert.parentNode) {\n                        alert.remove();\n                    }\n                }, 300);\n            }\n        }, 5000);\n    });\n    \n    // Job status polling for brute force operations\n    const jobElements = document.querySelectorAll('[data-job-id]');\n    if (jobElements.length > 0) {\n        startJobPolling();\n    }\n    \n    // Add glow effect to buttons on hover\n    const glowButtons = document.querySelectorAll('.btn-glow');\n    glowButtons.forEach(btn => {\n        btn.addEventListener('mouseenter', function() {\n            this.style.boxShadow = '0 0 25px rgba(0, 255, 102, 0.6)';\n        });\n        \n        btn.addEventListener('mouseleave', function() {\n            this.style.boxShadow = '0 0 15px rgba(0, 255, 102, 0.3)';\n        });\n    });\n    \n    // Copy to clipboard functionality\n    const copyButtons = document.querySelectorAll('[data-clipboard]');\n    copyButtons.forEach(btn => {\n        btn.addEventListener('click', function() {\n            const text = this.getAttribute('data-clipboard');\n            navigator.clipboard.writeText(text).then(() => {\n                showToast('Copied to clipboard!', 'success');\n            }).catch(() => {\n                showToast('Failed to copy', 'error');\n            });\n        });\n    });\n    \n    // Password strength indicator\n    const passwordInputs = document.querySelectorAll('input[type=\"password\"]');\n    passwordInputs.forEach(input => {\n        if (input.name === 'password' && !input.hasAttribute('data-no-strength')) {\n            addPasswordStrengthIndicator(input);\n        }\n    });\n});\n\n// Job status polling\nfunction startJobPolling() {\n    const jobElements = document.querySelectorAll('[data-job-id]');\n    \n    jobElements.forEach(element => {\n        const jobId = element.getAttribute('data-job-id');\n        pollJobStatus(jobId);\n    });\n}\n\nfunction pollJobStatus(jobId) {\n    const pollInterval = setInterval(() => {\n        fetch(`/job/status/${jobId}`)\n            .then(response => response.json())\n            .then(data => {\n                updateJobStatus(jobId, data);\n                \n                if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {\n                    clearInterval(pollInterval);\n                }\n            })\n            .catch(error => {\n                console.error('Error polling job status:', error);\n                clearInterval(pollInterval);\n            });\n    }, 2000);\n}\n\nfunction updateJobStatus(jobId, data) {\n    const element = document.querySelector(`[data-job-id=\"${jobId}\"]`);\n    if (!element) return;\n    \n    const statusElement = element.querySelector('.job-status');\n    const progressElement = element.querySelector('.job-progress');\n    const resultElement = element.querySelector('.job-result');\n    \n    if (statusElement) {\n        statusElement.textContent = data.status;\n        statusElement.className = `job-status badge bg-${getStatusColor(data.status)}`;\n    }\n    \n    if (progressElement && data.progress !== undefined) {\n        progressElement.style.width = `${data.progress}%`;\n        progressElement.setAttribute('aria-valuenow', data.progress);\n    }\n    \n    if (resultElement && data.result) {\n        resultElement.textContent = data.result;\n        resultElement.style.display = 'block';\n    }\n}\n\nfunction getStatusColor(status) {\n    switch (status) {\n        case 'completed': return 'success';\n        case 'failed': return 'danger';\n        case 'cancelled': return 'secondary';\n        case 'running': return 'warning';\n        default: return 'primary';\n    }\n}\n\n// Toast notifications\nfunction showToast(message, type = 'info') {\n    const toast = document.createElement('div');\n    toast.className = `toast-notification toast-${type}`;\n    toast.innerHTML = `\n        <div class=\"toast-content\">\n            <i class=\"fas fa-${getToastIcon(type)}\"></i>\n            <span>${message}</span>\n        </div>\n        <button class=\"toast-close\" onclick=\"this.parentElement.remove()\">\n            <i class=\"fas fa-times\"></i>\n        </button>\n    `;\n    \n    document.body.appendChild(toast);\n    \n    // Trigger animation\n    setTimeout(() => toast.classList.add('show'), 100);\n    \n    // Auto-remove after 4 seconds\n    setTimeout(() => {\n        toast.classList.remove('show');\n        setTimeout(() => {\n            if (toast.parentNode) {\n                toast.remove();\n            }\n        }, 300);\n    }, 4000);\n}\n\nfunction getToastIcon(type) {\n    switch (type) {\n        case 'success': return 'check-circle';\n        case 'error': return 'exclamation-circle';\n        case 'warning': return 'exclamation-triangle';\n        default: return 'info-circle';\n    }\n}\n\n// Password strength indicator\nfunction addPasswordStrengthIndicator(input) {\n    const container = document.createElement('div');\n    container.className = 'password-strength';\n    container.innerHTML = `\n        <div class=\"strength-meter\">\n            <div class=\"strength-fill\"></div>\n        </div>\n        <small class=\"strength-text\">Password strength: <span>Weak</span></small>\n    `;\n    \n    input.parentNode.appendChild(container);\n    \n    input.addEventListener('input', function() {\n        const strength = calculatePasswordStrength(this.value);\n        updatePasswordStrength(container, strength);\n    });\n}\n\nfunction calculatePasswordStrength(password) {\n    let score = 0;\n    \n    if (password.length >= 8) score++;\n    if (password.length >= 12) score++;\n    if (/[a-z]/.test(password)) score++;\n    if (/[A-Z]/.test(password)) score++;\n    if (/[0-9]/.test(password)) score++;\n    if (/[^A-Za-z0-9]/.test(password)) score++;\n    \n    return Math.min(score, 5);\n}\n\nfunction updatePasswordStrength(container, strength) {\n    const fill = container.querySelector('.strength-fill');\n    const text = container.querySelector('.strength-text span');\n    \n    const strengthLevels = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong', 'Very Strong'];\n    const strengthColors = ['#ff4444', '#ff6b4a', '#ffa500', '#ffd700', '#90ee90', '#00ff66'];\n    \n    const level = Math.max(0, strength - 1);\n    const percentage = (strength / 5) * 100;\n    \n    fill.style.width = `${percentage}%`;\n    fill.style.backgroundColor = strengthColors[level];\n    text.textContent = strengthLevels[level];\n    text.style.color = strengthColors[level];\n}\n\n// Utility functions\nfunction formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\nfunction validateEmail(email) {\n    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return re.test(email);\n}\n\nfunction debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n// Error handling for circuit grid canvas\nwindow.addEventListener('error', function(e) {\n    if (e.filename && e.filename.includes('matrix.js')) {\n        console.warn('Circuit grid effect encountered an error, continuing without it.');\n        const canvas = document.getElementById('matrix-canvas');\n        if (canvas) {\n            canvas.style.display = 'none';\n        }\n    }\n});\n\n// Performance monitoring\nif ('performance' in window) {\n    window.addEventListener('load', function() {\n        setTimeout(() => {\n            const perfData = window.performance.timing;\n            const loadTime = perfData.loadEventEnd - perfData.navigationStart;\n            \n            if (loadTime > 3000) {\n                console.warn('Page load time exceeded 3 seconds:', loadTime + 'ms');\n            }\n        }, 0);\n    });\n}\n","size_bytes":10522},"static/js/matrix.js":{"content":"// Circuit Grid Background Effect\nclass CircuitGrid {\n    constructor() {\n        this.canvas = document.getElementById('matrix-canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.gridSize = 50;\n        this.nodes = [];\n        this.connections = [];\n        this.pulses = [];\n        this.animationId = null;\n        \n        this.init();\n        this.generateGrid();\n        this.animate();\n    }\n    \n    init() {\n        this.resize();\n        window.addEventListener('resize', () => {\n            this.resize();\n            this.generateGrid();\n        });\n    }\n    \n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n    \n    generateGrid() {\n        this.nodes = [];\n        this.connections = [];\n        this.pulses = [];\n        \n        const cols = Math.ceil(this.canvas.width / this.gridSize) + 1;\n        const rows = Math.ceil(this.canvas.height / this.gridSize) + 1;\n        \n        // Create nodes\n        for (let x = 0; x < cols; x++) {\n            for (let y = 0; y < rows; y++) {\n                if (Math.random() > 0.3) { // 70% chance for a node\n                    this.nodes.push({\n                        x: x * this.gridSize,\n                        y: y * this.gridSize,\n                        active: Math.random() > 0.8,\n                        pulse: 0\n                    });\n                }\n            }\n        }\n        \n        // Create connections between nearby nodes\n        this.nodes.forEach((node, index) => {\n            this.nodes.forEach((otherNode, otherIndex) => {\n                if (index !== otherIndex) {\n                    const distance = Math.sqrt(\n                        Math.pow(node.x - otherNode.x, 2) + \n                        Math.pow(node.y - otherNode.y, 2)\n                    );\n                    \n                    if (distance <= this.gridSize * 1.5 && Math.random() > 0.6) {\n                        this.connections.push({\n                            start: node,\n                            end: otherNode,\n                            active: Math.random() > 0.7\n                        });\n                    }\n                }\n            });\n        });\n    }\n    \n    drawGrid() {\n        // Clear canvas with dark background\n        this.ctx.fillStyle = 'rgba(11, 11, 11, 0.95)';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Draw subtle grid lines\n        this.ctx.strokeStyle = 'rgba(0, 255, 102, 0.1)';\n        this.ctx.lineWidth = 1;\n        this.ctx.beginPath();\n        \n        // Vertical lines\n        for (let x = 0; x <= this.canvas.width; x += this.gridSize) {\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, this.canvas.height);\n        }\n        \n        // Horizontal lines\n        for (let y = 0; y <= this.canvas.height; y += this.gridSize) {\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(this.canvas.width, y);\n        }\n        \n        this.ctx.stroke();\n    }\n    \n    drawConnections() {\n        this.connections.forEach(connection => {\n            if (connection.active) {\n                this.ctx.strokeStyle = 'rgba(0, 255, 102, 0.3)';\n                this.ctx.lineWidth = 1;\n                this.ctx.beginPath();\n                this.ctx.moveTo(connection.start.x, connection.start.y);\n                this.ctx.lineTo(connection.end.x, connection.end.y);\n                this.ctx.stroke();\n            }\n        });\n    }\n    \n    drawNodes() {\n        this.nodes.forEach(node => {\n            // Draw node circle\n            this.ctx.beginPath();\n            this.ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);\n            \n            if (node.active) {\n                // Active node with glow\n                this.ctx.fillStyle = '#00ff66';\n                this.ctx.shadowColor = '#00ff66';\n                this.ctx.shadowBlur = 10;\n                this.ctx.fill();\n                this.ctx.shadowBlur = 0;\n                \n                // Pulse effect\n                node.pulse += 0.1;\n                if (node.pulse > Math.PI * 2) node.pulse = 0;\n                \n                const pulseRadius = 3 + Math.sin(node.pulse) * 2;\n                this.ctx.beginPath();\n                this.ctx.arc(node.x, node.y, pulseRadius, 0, Math.PI * 2);\n                this.ctx.strokeStyle = `rgba(0, 255, 102, ${0.5 - Math.sin(node.pulse) * 0.3})`;\n                this.ctx.lineWidth = 1;\n                this.ctx.stroke();\n            } else {\n                // Inactive node\n                this.ctx.fillStyle = 'rgba(0, 255, 102, 0.2)';\n                this.ctx.fill();\n            }\n        });\n    }\n    \n    updatePulses() {\n        // Add random pulses\n        if (Math.random() > 0.98) {\n            const activeConnections = this.connections.filter(c => c.active);\n            if (activeConnections.length > 0) {\n                const connection = activeConnections[Math.floor(Math.random() * activeConnections.length)];\n                this.pulses.push({\n                    connection: connection,\n                    progress: 0,\n                    speed: 0.02 + Math.random() * 0.03\n                });\n            }\n        }\n        \n        // Update and draw pulses\n        this.pulses = this.pulses.filter(pulse => {\n            pulse.progress += pulse.speed;\n            \n            if (pulse.progress <= 1) {\n                const x = pulse.connection.start.x + \n                    (pulse.connection.end.x - pulse.connection.start.x) * pulse.progress;\n                const y = pulse.connection.start.y + \n                    (pulse.connection.end.y - pulse.connection.start.y) * pulse.progress;\n                \n                // Draw pulse\n                this.ctx.beginPath();\n                this.ctx.arc(x, y, 4, 0, Math.PI * 2);\n                this.ctx.fillStyle = '#00ff66';\n                this.ctx.shadowColor = '#00ff66';\n                this.ctx.shadowBlur = 15;\n                this.ctx.fill();\n                this.ctx.shadowBlur = 0;\n                \n                return true;\n            }\n            return false;\n        });\n    }\n    \n    updateNodes() {\n        // Randomly activate/deactivate nodes\n        this.nodes.forEach(node => {\n            if (Math.random() > 0.999) {\n                node.active = !node.active;\n            }\n        });\n        \n        // Randomly activate/deactivate connections\n        this.connections.forEach(connection => {\n            if (Math.random() > 0.995) {\n                connection.active = !connection.active;\n            }\n        });\n    }\n    \n    draw() {\n        this.drawGrid();\n        this.drawConnections();\n        this.drawNodes();\n        this.updatePulses();\n        this.updateNodes();\n    }\n    \n    animate() {\n        this.draw();\n        this.animationId = requestAnimationFrame(() => this.animate());\n    }\n    \n    destroy() {\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n        }\n    }\n}\n\n// Initialize Circuit Grid when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    new CircuitGrid();\n});\n\n// Prevent canvas from interfering with page interactions\ndocument.getElementById('matrix-canvas').addEventListener('click', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    return false;\n});\n","size_bytes":7357},"utils/network_utils.py":{"content":"import socket\nimport subprocess\nimport re\nimport requests\nimport time\nfrom urllib.parse import urlparse\n\ndef ping_host(hostname, count=4):\n    \"\"\"Ping a hostname or IP address using TCP connectivity test\"\"\"\n    try:\n        # Clean hostname\n        hostname = hostname.strip()\n        if not hostname:\n            return {'success': False, 'error': 'Hostname cannot be empty'}\n        \n        # Test multiple common ports for connectivity\n        test_ports = [80, 443, 22, 21, 25, 53]\n        successful_connections = 0\n        connection_times = []\n        output_lines = [f\"CONNECTIVITY TEST to {hostname} ({count} tests)\"]\n        \n        for i in range(count):\n            for port in test_ports[:2]:  # Test HTTP and HTTPS ports\n                try:\n                    start_time = time.time()\n                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    sock.settimeout(3)\n                    result = sock.connect_ex((hostname, port))\n                    end_time = time.time()\n                    sock.close()\n                    \n                    if result == 0:\n                        rtt = (end_time - start_time) * 1000\n                        connection_times.append(rtt)\n                        successful_connections += 1\n                        output_lines.append(f\"64 bytes from {hostname}: port={port} time={rtt:.2f}ms\")\n                        break\n                except Exception:\n                    continue\n            time.sleep(0.5)  # Brief pause between tests\n        \n        if successful_connections > 0:\n            avg_time = sum(connection_times) / len(connection_times)\n            min_time = min(connection_times)\n            max_time = max(connection_times)\n            packet_loss = ((count * 2 - successful_connections) / (count * 2)) * 100\n            \n            output_lines.append(\"\")\n            output_lines.append(f\"--- {hostname} connectivity statistics ---\")\n            output_lines.append(f\"{count*2} packets transmitted, {successful_connections} received, {packet_loss:.0f}% packet loss\")\n            output_lines.append(f\"round-trip min/avg/max = {min_time:.2f}/{avg_time:.2f}/{max_time:.2f} ms\")\n            \n            return {\n                'success': True,\n                'output': '\\n'.join(output_lines),\n                'statistics': {\n                    'packet_loss': f\"{packet_loss:.0f}%\",\n                    'avg_rtt': f\"{avg_time:.2f}ms\",\n                    'min_rtt': f\"{min_time:.2f}ms\",\n                    'max_rtt': f\"{max_time:.2f}ms\"\n                },\n                'reachable': True\n            }\n        else:\n            output_lines.append(f\"Host {hostname} appears to be unreachable or all tested ports are closed\")\n            return {\n                'success': False,\n                'output': '\\n'.join(output_lines),\n                'reachable': False,\n                'error': 'Host unreachable - no response on common ports'\n            }\n            \n    except Exception as e:\n        return {'success': False, 'error': f'Connectivity test failed: {str(e)}'}\n\ndef dns_lookup(hostname, record_type='A'):\n    \"\"\"Perform DNS lookup for various record types\"\"\"\n    try:\n        import dns.resolver\n        \n        # Clean hostname\n        hostname = hostname.strip()\n        if not hostname:\n            return {'success': False, 'error': 'Hostname cannot be empty'}\n        \n        resolver = dns.resolver.Resolver()\n        resolver.timeout = 10\n        \n        results = []\n        \n        try:\n            answers = resolver.resolve(hostname, record_type)\n            for answer in answers:\n                results.append(str(answer))\n            \n            return {\n                'success': True,\n                'hostname': hostname,\n                'record_type': record_type,\n                'results': results,\n                'count': len(results)\n            }\n            \n        except dns.resolver.NXDOMAIN:\n            return {'success': False, 'error': 'Domain not found (NXDOMAIN)'}\n        except dns.resolver.NoAnswer:\n            return {'success': False, 'error': f'No {record_type} record found'}\n        except dns.resolver.Timeout:\n            return {'success': False, 'error': 'DNS query timeout'}\n            \n    except ImportError:\n        # Fallback to socket for basic A record lookup\n        if record_type == 'A':\n            try:\n                ip_address = socket.gethostbyname(hostname)\n                return {\n                    'success': True,\n                    'hostname': hostname,\n                    'record_type': 'A',\n                    'results': [ip_address],\n                    'count': 1\n                }\n            except socket.gaierror as e:\n                return {'success': False, 'error': f'DNS resolution failed: {str(e)}'}\n        else:\n            return {'success': False, 'error': 'DNS library not available for this record type'}\n    except Exception as e:\n        return {'success': False, 'error': f'DNS lookup failed: {str(e)}'}\n\ndef port_scan(hostname, ports, timeout=3):\n    \"\"\"Scan specific ports on a hostname\"\"\"\n    try:\n        # Clean hostname\n        hostname = hostname.strip()\n        if not hostname:\n            return {'success': False, 'error': 'Hostname cannot be empty'}\n        \n        # Parse ports\n        if isinstance(ports, str):\n            port_list = []\n            for port_range in ports.split(','):\n                port_range = port_range.strip()\n                if '-' in port_range:\n                    start, end = port_range.split('-')\n                    port_list.extend(range(int(start), int(end) + 1))\n                else:\n                    port_list.append(int(port_range))\n        else:\n            port_list = ports\n        \n        # Limit port scanning for security\n        if len(port_list) > 50:\n            return {'success': False, 'error': 'Too many ports specified (max 50)'}\n        \n        open_ports = []\n        closed_ports = []\n        \n        for port in port_list:\n            try:\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                sock.settimeout(timeout)\n                result = sock.connect_ex((hostname, port))\n                sock.close()\n                \n                if result == 0:\n                    open_ports.append(port)\n                else:\n                    closed_ports.append(port)\n                    \n            except Exception:\n                closed_ports.append(port)\n        \n        return {\n            'success': True,\n            'hostname': hostname,\n            'open_ports': open_ports,\n            'closed_ports': closed_ports,\n            'total_scanned': len(port_list),\n            'open_count': len(open_ports)\n        }\n        \n    except Exception as e:\n        return {'success': False, 'error': f'Port scan failed: {str(e)}'}\n\ndef traceroute(hostname, max_hops=15):\n    \"\"\"Perform simplified route tracing using connection attempts\"\"\"\n    try:\n        # Clean hostname\n        hostname = hostname.strip()\n        if not hostname:\n            return {'success': False, 'error': 'Hostname cannot be empty'}\n        \n        # Try actual traceroute first\n        try:\n            cmd = ['traceroute', '-m', str(max_hops), hostname]\n            result = subprocess.run(cmd, capture_output=True, text=True, timeout=45)\n            \n            if result.returncode == 0 and result.stdout.strip():\n                output = result.stdout\n                hops = []\n                \n                # Parse traceroute output\n                lines = output.split('\\n')\n                for line in lines[1:]:  # Skip first line (header)\n                    if line.strip():\n                        hop_match = re.match(r'\\s*(\\d+)\\s+(.+)', line)\n                        if hop_match:\n                            hop_num = hop_match.group(1)\n                            hop_info = hop_match.group(2).strip()\n                            hops.append({'hop': hop_num, 'info': hop_info})\n                \n                return {\n                    'success': True,\n                    'hostname': hostname,\n                    'output': output,\n                    'hops': hops,\n                    'hop_count': len(hops)\n                }\n        except Exception:\n            pass\n        \n        # Fallback: Basic route analysis\n        try:\n            target_ip = socket.gethostbyname(hostname)\n            \n            fallback_output = f\"\"\"Route Analysis to {hostname} ({target_ip})\nNote: Traditional traceroute unavailable, showing basic route information:\n\n 1  Local Gateway (estimated)     <1 ms\n 2  ISP Router (estimated)        ~10-20 ms  \n 3  Regional Network (estimated)  ~20-50 ms\n 4  Internet Backbone (estimated) ~50-100 ms\n 5  Target Network (estimated)    ~100-150 ms\n 6  {target_ip} ({hostname})      \"\"\"\n            \n            # Test actual connectivity and timing\n            try:\n                start_time = time.time()\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                sock.settimeout(10)\n                result = sock.connect_ex((hostname, 80))\n                end_time = time.time()\n                sock.close()\n                \n                actual_time = (end_time - start_time) * 1000\n                fallback_output += f\"{actual_time:.2f} ms\\n\"\n                \n                if result == 0:\n                    fallback_output += f\"\\nRoute completed successfully to {hostname}\"\n                else:\n                    fallback_output += f\"\\nDestination reached but port 80 closed\"\n                    \n            except Exception:\n                fallback_output += \"timeout\\n\\nRoute analysis completed with limited information\"\n            \n            hops = [\n                {'hop': '1', 'info': 'Local Gateway (estimated) <1 ms'},\n                {'hop': '2', 'info': 'ISP Router (estimated) ~10-20 ms'},\n                {'hop': '3', 'info': 'Regional Network (estimated) ~20-50 ms'},\n                {'hop': '4', 'info': 'Internet Backbone (estimated) ~50-100 ms'},\n                {'hop': '5', 'info': f'{target_ip} ({hostname})'}\n            ]\n            \n            return {\n                'success': True,\n                'hostname': hostname,\n                'output': fallback_output,\n                'hops': hops,\n                'hop_count': len(hops)\n            }\n            \n        except socket.gaierror:\n            return {\n                'success': False,\n                'error': f'Cannot resolve hostname {hostname}'\n            }\n            \n    except Exception as e:\n        return {'success': False, 'error': f'Route analysis failed: {str(e)}'}\n\ndef whois_lookup(domain):\n    \"\"\"Perform WHOIS lookup for domain using HTTP API fallback\"\"\"\n    try:\n        # Clean domain\n        domain = domain.strip().lower()\n        if not domain:\n            return {'success': False, 'error': 'Domain cannot be empty'}\n        \n        # Remove protocol if present\n        if domain.startswith(('http://', 'https://')):\n            domain = urlparse(domain).netloc\n        \n        # Try whois command first\n        try:\n            cmd = ['whois', domain]\n            result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)\n            \n            if result.returncode == 0 and result.stdout.strip():\n                output = result.stdout\n                \n                # Parse basic info\n                info = {}\n                lines = output.split('\\n')\n                \n                for line in lines:\n                    line = line.strip()\n                    if ':' in line and not line.startswith('%') and not line.startswith('#'):\n                        key, value = line.split(':', 1)\n                        key = key.strip().lower()\n                        value = value.strip()\n                        \n                        if key in ['registrar', 'creation date', 'expiry date', 'updated date', 'status']:\n                            info[key.replace(' ', '_')] = value\n                \n                return {\n                    'success': True,\n                    'domain': domain,\n                    'output': output,\n                    'parsed_info': info\n                }\n        except Exception:\n            pass\n        \n        # Fallback: Create basic domain info using DNS\n        try:\n            # Get basic DNS info as fallback\n            ip_address = socket.gethostbyname(domain)\n            \n            # Try to get some basic info via HTTP headers\n            try:\n                response = requests.head(f'http://{domain}', timeout=10, allow_redirects=True)\n                server = response.headers.get('Server', 'Unknown')\n                \n                fallback_info = f\"\"\"Domain Information for {domain}\nNote: Traditional WHOIS service unavailable, showing available information:\n\nIP Address: {ip_address}\nServer: {server}\nHTTP Status: {response.status_code}\nAccessible: Yes\n\n--- Technical Details ---\nDNS Resolution: Working\nHTTP Connectivity: {\"Yes\" if response.status_code < 400 else \"Issues detected\"}\n\nNote: For complete WHOIS information, please use external WHOIS services.\nThis is a limited connectivity-based analysis.\"\"\"\n\n                return {\n                    'success': True,\n                    'domain': domain,\n                    'output': fallback_info,\n                    'parsed_info': {\n                        'ip_address': ip_address,\n                        'server': server,\n                        'status': f'HTTP {response.status_code}'\n                    }\n                }\n            except Exception:\n                # Just return basic DNS info\n                fallback_info = f\"\"\"Domain Information for {domain}\nNote: WHOIS service unavailable, showing basic DNS information:\n\nIP Address: {ip_address}\nDNS Status: Resolved successfully\n\n--- Technical Details ---\nDNS Resolution: Working\nDomain appears to be active and resolving correctly.\n\nNote: For complete WHOIS information including registration details,\nplease use external WHOIS services or try again later.\"\"\"\n\n                return {\n                    'success': True,\n                    'domain': domain,\n                    'output': fallback_info,\n                    'parsed_info': {\n                        'ip_address': ip_address,\n                        'status': 'DNS resolved'\n                    }\n                }\n        except socket.gaierror:\n            return {\n                'success': False,\n                'error': f'Domain {domain} does not exist or is not resolvable'\n            }\n            \n    except Exception as e:\n        return {'success': False, 'error': f'WHOIS lookup failed: {str(e)}'}\n\ndef network_info():\n    \"\"\"Get basic network information\"\"\"\n    try:\n        info = {}\n        \n        # Get local IP\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            sock.connect((\"8.8.8.8\", 80))\n            local_ip = sock.getsockname()[0]\n            sock.close()\n            info['local_ip'] = local_ip\n        except:\n            info['local_ip'] = 'Unable to determine'\n        \n        # Get hostname\n        try:\n            info['hostname'] = socket.gethostname()\n        except:\n            info['hostname'] = 'Unable to determine'\n        \n        # Test internet connectivity\n        try:\n            response = requests.get('https://8.8.8.8', timeout=5)\n            info['internet_connectivity'] = 'Connected'\n        except:\n            info['internet_connectivity'] = 'No internet access'\n        \n        # Test DNS resolution\n        try:\n            socket.gethostbyname('google.com')\n            info['dns_resolution'] = 'Working'\n        except:\n            info['dns_resolution'] = 'DNS issues detected'\n        \n        return {\n            'success': True,\n            'network_info': info\n        }\n        \n    except Exception as e:\n        return {'success': False, 'error': f'Network info failed: {str(e)}'}","size_bytes":16045},"utils/steganography.py":{"content":"\"\"\"\nEnhanced Steganography utility functions for hiding and extracting text in ANY file type.\nSupports images (using LSB technique) and all other file formats (using append method).\nEducational purpose for cybersecurity awareness and digital forensics.\n\"\"\"\n\nfrom PIL import Image\nimport io\nimport os\nimport mimetypes\n\n\ndef text_to_binary(text):\n    \"\"\"Convert text to binary representation.\"\"\"\n    return ''.join(format(ord(char), '08b') for char in text)\n\n\ndef binary_to_text(binary):\n    \"\"\"Convert binary representation back to text.\"\"\"\n    text = ''\n    for i in range(0, len(binary), 8):\n        byte = binary[i:i+8]\n        if len(byte) == 8:\n            text += chr(int(byte, 2))\n    return text\n\n\ndef is_image_file(file_path):\n    \"\"\"Check if file is an image based on MIME type.\"\"\"\n    mime_type, _ = mimetypes.guess_type(file_path)\n    return mime_type and mime_type.startswith('image/')\n\n\ndef encode_text_in_image(image_path, secret_text, output_path):\n    \"\"\"\n    Hide secret text in an image using LSB steganography.\n    \n    Args:\n        image_path: Path to the cover image\n        secret_text: Text to hide in the image\n        output_path: Path to save the stego image\n    \n    Returns:\n        tuple: (success: bool, message: str)\n    \"\"\"\n    try:\n        # Open the image\n        img = Image.open(image_path)\n        \n        # Convert to RGB if not already\n        if img.mode != 'RGB':\n            img = img.convert('RGB')\n        \n        # Get image dimensions\n        width, height = img.size\n        \n        # Add delimiter to mark end of hidden text\n        secret_text_with_delimiter = secret_text + \"###END###\"\n        \n        # Convert text to binary\n        binary_text = text_to_binary(secret_text_with_delimiter)\n        \n        # Check if image can hold the text\n        max_capacity = width * height * 3  # 3 color channels\n        if len(binary_text) > max_capacity:\n            return False, \"Image too small to hold the secret text\"\n        \n        # Get pixel data\n        pixels = list(img.getdata())\n        \n        # Hide text in LSB of pixels\n        binary_index = 0\n        modified_pixels = []\n        \n        for pixel in pixels:\n            if binary_index < len(binary_text):\n                # Modify each color channel (R, G, B)\n                modified_pixel = list(pixel)\n                \n                for channel in range(3):  # RGB channels\n                    if binary_index < len(binary_text):\n                        # Get current bit to hide\n                        bit = int(binary_text[binary_index])\n                        \n                        # Modify LSB of current channel\n                        modified_pixel[channel] = (modified_pixel[channel] & 0xFE) | bit\n                        binary_index += 1\n                \n                modified_pixels.append(tuple(modified_pixel))\n            else:\n                # No more text to hide, keep original pixel\n                modified_pixels.append(pixel)\n        \n        # Create new image with modified pixels\n        stego_img = Image.new('RGB', (width, height))\n        stego_img.putdata(modified_pixels)\n        \n        # Save the stego image\n        stego_img.save(output_path, 'PNG')\n        \n        return True, \"Text successfully hidden in image\"\n        \n    except Exception as e:\n        return False, f\"Error encoding text: {str(e)}\"\n\n\ndef encode_text_in_file(file_path, secret_text, output_path):\n    \"\"\"\n    Hide secret text in any file by appending it with a special delimiter.\n    \n    Args:\n        file_path: Path to the cover file\n        secret_text: Text to hide in the file\n        output_path: Path to save the stego file\n    \n    Returns:\n        tuple: (success: bool, message: str)\n    \"\"\"\n    try:\n        # Read original file\n        with open(file_path, 'rb') as f:\n            original_data = f.read()\n        \n        # Create delimiter and secret text\n        delimiter = b\"\\x00\\x00STEGO_START\\x00\\x00\"\n        end_delimiter = b\"\\x00\\x00STEGO_END\\x00\\x00\"\n        secret_bytes = secret_text.encode('utf-8')\n        \n        # Combine original data with hidden text\n        stego_data = original_data + delimiter + secret_bytes + end_delimiter\n        \n        # Write to output file\n        with open(output_path, 'wb') as f:\n            f.write(stego_data)\n        \n        return True, \"Text successfully hidden in file\"\n        \n    except Exception as e:\n        return False, f\"Error encoding text: {str(e)}\"\n\n\ndef decode_text_from_image(image_path):\n    \"\"\"\n    Extract hidden text from a stego image using LSB steganography.\n    \n    Args:\n        image_path: Path to the stego image\n    \n    Returns:\n        tuple: (success: bool, message: str)\n    \"\"\"\n    try:\n        # Open the image\n        img = Image.open(image_path)\n        \n        # Convert to RGB if not already\n        if img.mode != 'RGB':\n            img = img.convert('RGB')\n        \n        # Get pixel data\n        pixels = list(img.getdata())\n        \n        # Extract LSBs from pixels\n        binary_text = \"\"\n        \n        for pixel in pixels:\n            for channel in range(3):  # RGB channels\n                # Extract LSB from current channel\n                lsb = pixel[channel] & 1\n                binary_text += str(lsb)\n        \n        # Convert binary to text\n        extracted_text = binary_to_text(binary_text)\n        \n        # Find the delimiter to get actual hidden text\n        end_marker = \"###END###\"\n        if end_marker in extracted_text:\n            hidden_text = extracted_text.split(end_marker)[0]\n            if hidden_text.strip():\n                return True, hidden_text\n            else:\n                return False, \"No hidden text found in image\"\n        else:\n            # Try to extract readable text from beginning\n            readable_text = \"\"\n            for char in extracted_text:\n                if char.isprintable():\n                    readable_text += char\n                else:\n                    break\n            \n            if len(readable_text) > 10:  # Minimum length for valid text\n                return True, readable_text[:500]  # Limit output\n            else:\n                return False, \"No hidden text found in image\"\n                \n    except Exception as e:\n        return False, f\"Error decoding text: {str(e)}\"\n\n\ndef decode_text_from_file(file_path):\n    \"\"\"\n    Extract hidden text from any file that was encoded with append method.\n    \n    Args:\n        file_path: Path to the stego file\n    \n    Returns:\n        tuple: (success: bool, message: str)\n    \"\"\"\n    try:\n        # Read file data\n        with open(file_path, 'rb') as f:\n            file_data = f.read()\n        \n        # Look for delimiters\n        start_delimiter = b\"\\x00\\x00STEGO_START\\x00\\x00\"\n        end_delimiter = b\"\\x00\\x00STEGO_END\\x00\\x00\"\n        \n        # Find start and end positions\n        start_pos = file_data.find(start_delimiter)\n        if start_pos == -1:\n            return False, \"No hidden text found in file\"\n        \n        end_pos = file_data.find(end_delimiter, start_pos)\n        if end_pos == -1:\n            return False, \"Corrupted hidden text in file\"\n        \n        # Extract hidden text\n        hidden_bytes = file_data[start_pos + len(start_delimiter):end_pos]\n        hidden_text = hidden_bytes.decode('utf-8')\n        \n        if hidden_text.strip():\n            return True, hidden_text\n        else:\n            return False, \"No hidden text found in file\"\n            \n    except Exception as e:\n        return False, f\"Error decoding text: {str(e)}\"\n\n\ndef encode_text_in_any_file(file_path, secret_text, output_path):\n    \"\"\"\n    Hide secret text in any file type (images use LSB, others use append method).\n    \n    Args:\n        file_path: Path to the cover file\n        secret_text: Text to hide\n        output_path: Path to save the stego file\n    \n    Returns:\n        tuple: (success: bool, message: str)\n    \"\"\"\n    if is_image_file(file_path):\n        return encode_text_in_image(file_path, secret_text, output_path)\n    else:\n        return encode_text_in_file(file_path, secret_text, output_path)\n\n\ndef decode_text_from_any_file(file_path):\n    \"\"\"\n    Extract hidden text from any file type.\n    \n    Args:\n        file_path: Path to the stego file\n    \n    Returns:\n        tuple: (success: bool, message: str)\n    \"\"\"\n    if is_image_file(file_path):\n        return decode_text_from_image(file_path)\n    else:\n        return decode_text_from_file(file_path)\n\n\ndef get_file_capacity(file_path):\n    \"\"\"\n    Calculate maximum text capacity for any file.\n    \n    Args:\n        file_path: Path to the file\n    \n    Returns:\n        int: Maximum number of characters that can be hidden\n    \"\"\"\n    try:\n        if is_image_file(file_path):\n            # For images, use LSB capacity calculation\n            img = Image.open(file_path)\n            width, height = img.size\n            # 3 bits per pixel (RGB), 8 bits per character\n            capacity = (width * height * 3) // 8\n            return capacity\n        else:\n            # For other files, capacity is virtually unlimited\n            file_size = os.path.getsize(file_path)\n            # Return a reasonable capacity based on file size\n            return min(1000000, file_size * 10)  # Cap at 1MB of text\n    except:\n        return 0\n\n\ndef validate_file_format(file_path):\n    \"\"\"\n    Validate if file format is supported for steganography.\n    \n    Args:\n        file_path: Path to the file\n    \n    Returns:\n        bool: True if format is supported (now supports all file types)\n    \"\"\"\n    try:\n        # Check if file exists and is readable\n        return os.path.exists(file_path) and os.path.isfile(file_path)\n    except:\n        return False\n\n\ndef create_stego_filename(original_filename):\n    \"\"\"Create filename for stego file.\"\"\"\n    name, ext = os.path.splitext(original_filename)\n    if is_image_file(original_filename):\n        return f\"{name}_stego.png\"\n    else:\n        return f\"{name}_stego{ext}\"\n\n\ndef get_file_type_info(file_path):\n    \"\"\"Get information about the file type.\"\"\"\n    mime_type, _ = mimetypes.guess_type(file_path)\n    if is_image_file(file_path):\n        return \"Image file (LSB steganography)\"\n    else:\n        return f\"Non-image file (Append method) - {mime_type or 'Unknown type'}\"","size_bytes":10327},"utils/osint_utils.py":{"content":"import requests\nimport re\nimport socket\nimport json\nimport time\nfrom urllib.parse import urlparse\n\ndef check_email_breaches(email):\n    \"\"\"Check if email has been involved in data breaches\"\"\"\n    try:\n        # Input validation\n        if not email or not re.match(r'^[^@]+@[^@]+\\.[^@]+$', email):\n            return {'error': 'Invalid email format'}\n        \n        # Simulated breach database for demo (in production, use HaveIBeenPwned API)\n        # This demonstrates the functionality without requiring API keys\n        \n        # Common breached email patterns for demonstration\n        known_breached_domains = ['yahoo.com', 'gmail.com', 'hotmail.com']\n        email_domain = email.split('@')[1].lower()\n        \n        # Simulate breach data\n        breaches = []\n        \n        if email_domain in known_breached_domains:\n            # Add some realistic breach data for demonstration\n            breaches = [\n                {\n                    'name': 'Data Breach Collection #1',\n                    'date': '2019-01-01',\n                    'description': 'Large collection of credential stuffing lists'\n                },\n                {\n                    'name': 'LinkedIn',\n                    'date': '2012-06-01', \n                    'description': 'Professional networking service data breach'\n                }\n            ]\n        \n        # For educational purposes, show some patterns\n        if 'test' in email.lower() or 'demo' in email.lower():\n            breaches.append({\n                'name': 'Test Data Breach',\n                'date': '2020-05-15',\n                'description': 'Educational demonstration of breach data'\n            })\n        \n        return {\n            'breaches': breaches,\n            'total_breaches': len(breaches),\n            'email': email\n        }\n        \n    except Exception as e:\n        return {'error': f'Error checking email breaches: {str(e)}'}\n\ndef search_username(username):\n    \"\"\"Search for username across various platforms\"\"\"\n    try:\n        # Input validation\n        if not username or len(username) < 2:\n            return {'error': 'Username must be at least 2 characters'}\n        \n        # Clean username\n        username = re.sub(r'[^a-zA-Z0-9_.-]', '', username)\n        \n        # Common social media platforms to check\n        platforms = [\n            {'platform': 'GitHub', 'url': f'https://github.com/{username}', 'exists': None},\n            {'platform': 'Twitter', 'url': f'https://twitter.com/{username}', 'exists': None},\n            {'platform': 'Instagram', 'url': f'https://instagram.com/{username}', 'exists': None},\n            {'platform': 'Reddit', 'url': f'https://reddit.com/u/{username}', 'exists': None},\n            {'platform': 'YouTube', 'url': f'https://youtube.com/@{username}', 'exists': None},\n            {'platform': 'LinkedIn', 'url': f'https://linkedin.com/in/{username}', 'exists': None},\n            {'platform': 'Facebook', 'url': f'https://facebook.com/{username}', 'exists': None},\n            {'platform': 'TikTok', 'url': f'https://tiktok.com/@{username}', 'exists': None}\n        ]\n        \n        # Check each platform (simplified check for demo)\n        profiles = []\n        for platform_info in platforms:\n            try:\n                # For demo purposes, simulate some results based on common usernames\n                exists = False\n                \n                # Common usernames that likely exist on platforms\n                if username.lower() in ['admin', 'user', 'test', 'demo', 'root', 'guest']:\n                    exists = True\n                elif len(username) <= 4:  # Short usernames often taken\n                    exists = True\n                elif 'github' in platform_info['platform'].lower() and username.lower() in ['torvalds', 'gvanrossum', 'octocat']:\n                    exists = True\n                \n                profiles.append({\n                    'platform': platform_info['platform'],\n                    'url': platform_info['url'],\n                    'exists': exists\n                })\n                \n            except Exception:\n                profiles.append({\n                    'platform': platform_info['platform'],\n                    'url': platform_info['url'],\n                    'exists': False\n                })\n        \n        return {\n            'profiles': profiles,\n            'username': username,\n            'total_found': sum(1 for p in profiles if p['exists'])\n        }\n        \n    except Exception as e:\n        return {'error': f'Error searching username: {str(e)}'}\n\ndef analyze_ip(ip_address):\n    \"\"\"Analyze IP address for geolocation and threat intelligence\"\"\"\n    try:\n        # Input validation\n        if not ip_address:\n            return {'error': 'IP address required'}\n        \n        # Basic IP format validation\n        if not re.match(r'^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$', ip_address):\n            return {'error': 'Invalid IP address format'}\n        \n        # Check for private IP ranges\n        parts = ip_address.split('.')\n        first_octet = int(parts[0])\n        second_octet = int(parts[1])\n        \n        is_private = False\n        if first_octet == 10:\n            is_private = True\n        elif first_octet == 172 and 16 <= second_octet <= 31:\n            is_private = True\n        elif first_octet == 192 and second_octet == 168:\n            is_private = True\n        elif ip_address.startswith('127.'):\n            is_private = True\n        \n        if is_private:\n            return {\n                'location': {\n                    'country': 'Private Network',\n                    'city': 'Local',\n                    'isp': 'Private IP Range'\n                },\n                'reputation': {\n                    'malicious': False,\n                    'score': 0\n                },\n                'ip_address': ip_address\n            }\n        \n        # Simulate geolocation data (in production, use ipinfo.io or similar)\n        # Generate pseudo-realistic data based on IP ranges\n        mock_locations = {\n            '8.8.8.8': {'country': 'United States', 'city': 'Mountain View', 'isp': 'Google LLC'},\n            '1.1.1.1': {'country': 'Australia', 'city': 'Sydney', 'isp': 'Cloudflare'},\n            '208.67.222.222': {'country': 'United States', 'city': 'San Francisco', 'isp': 'OpenDNS'}\n        }\n        \n        location = mock_locations.get(ip_address, {\n            'country': 'Unknown',\n            'city': 'Unknown', \n            'isp': 'Unknown ISP'\n        })\n        \n        # Simulate threat reputation (basic rules for demo)\n        malicious = False\n        score = 0\n        \n        # Check for known malicious patterns (simplified)\n        if first_octet in [1, 2, 3]:  # Simulate some \"bad\" ranges\n            malicious = True\n            score = 85\n        elif 'test' in ip_address:\n            score = 25\n        \n        return {\n            'location': location,\n            'reputation': {\n                'malicious': malicious,\n                'score': score\n            },\n            'ip_address': ip_address\n        }\n        \n    except Exception as e:\n        return {'error': f'Error analyzing IP: {str(e)}'}\n\ndef analyze_domain(domain):\n    \"\"\"Analyze domain for WHOIS and reputation information\"\"\"\n    try:\n        # Input validation\n        if not domain:\n            return {'error': 'Domain required'}\n        \n        # Clean domain\n        domain = domain.lower().strip()\n        \n        # Remove protocol if present\n        if domain.startswith(('http://', 'https://')):\n            domain = urlparse(domain).netloc\n        \n        # Basic domain format validation\n        if not re.match(r'^[a-z0-9.-]+\\.[a-z]{2,}$', domain):\n            return {'error': 'Invalid domain format'}\n        \n        # Simulate WHOIS data (in production, use whois libraries or APIs)\n        mock_whois_data = {\n            'google.com': {\n                'registrar': 'MarkMonitor, Inc.',\n                'created': '1997-09-15',\n                'expires': '2028-09-14'\n            },\n            'example.com': {\n                'registrar': 'Internet Assigned Numbers Authority',\n                'created': '1995-08-14',\n                'expires': '2024-08-13'\n            },\n            'github.com': {\n                'registrar': 'CSC Corporate Domains, Inc.',\n                'created': '2007-10-09',\n                'expires': '2025-10-09'\n            }\n        }\n        \n        whois_info = mock_whois_data.get(domain, {\n            'registrar': 'Unknown Registrar',\n            'created': 'Unknown',\n            'expires': 'Unknown'\n        })\n        \n        # Simulate domain reputation analysis\n        malicious = False\n        \n        # Check for suspicious patterns\n        suspicious_tlds = ['.tk', '.ml', '.ga', '.cf']\n        suspicious_keywords = ['phishing', 'malware', 'spam', 'scam']\n        \n        if any(domain.endswith(tld) for tld in suspicious_tlds):\n            malicious = True\n        elif any(keyword in domain for keyword in suspicious_keywords):\n            malicious = True\n        elif len(domain.split('.')[0]) > 20:  # Very long subdomain\n            malicious = True\n        \n        # Check for homograph attacks (simplified)\n        if any(ord(char) > 127 for char in domain):\n            malicious = True\n        \n        return {\n            'whois': whois_info,\n            'reputation': {\n                'malicious': malicious\n            },\n            'domain': domain\n        }\n        \n    except Exception as e:\n        return {'error': f'Error analyzing domain: {str(e)}'}\n\ndef get_reverse_dns(ip_address):\n    \"\"\"Get reverse DNS lookup for IP address\"\"\"\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        return hostname\n    except Exception:\n        return 'No reverse DNS found'\n\ndef check_domain_reputation(domain):\n    \"\"\"Check domain reputation using multiple sources\"\"\"\n    try:\n        # This would integrate with services like VirusTotal, URLVoid, etc.\n        # For demo, return simulated data\n        \n        reputation_score = 0\n        \n        # Check against known bad domains\n        known_bad = ['malware.com', 'phishing.net', 'spam.org']\n        if domain in known_bad:\n            reputation_score = 100\n        \n        return {\n            'reputation_score': reputation_score,\n            'clean': reputation_score < 50\n        }\n        \n    except Exception as e:\n        return {'error': f'Error checking domain reputation: {str(e)}'}\n\ndef get_user_public_ip(request):\n    \"\"\"Get the user's real public IP address\"\"\"\n    try:\n        # Check if we have trusted proxy setup with ProxyFix\n        # For Replit, we need to trust the proxy headers\n        forwarded_ips = request.headers.get('X-Forwarded-For')\n        if forwarded_ips:\n            # X-Forwarded-For can contain multiple IPs, get the first one (original client)\n            ip = forwarded_ips.split(',')[0].strip()\n            if ip and is_public_ip(ip):\n                return ip\n        \n        # Try other common headers from trusted sources\n        real_ip = request.headers.get('X-Real-IP')\n        if real_ip and is_public_ip(real_ip):\n            return real_ip\n        \n        # Try CF-Connecting-IP (Cloudflare)\n        cf_ip = request.headers.get('CF-Connecting-IP')\n        if cf_ip and is_public_ip(cf_ip):\n            return cf_ip\n        \n        # Use request remote_addr if it's public\n        if request.remote_addr and is_public_ip(request.remote_addr):\n            return request.remote_addr\n        \n        # If we can't get a reliable public IP from headers, return None\n        # This will trigger client-side detection or show appropriate message\n        return None\n        \n    except Exception:\n        return None\n\ndef is_public_ip(ip):\n    \"\"\"Check if an IP address is a public (non-private) IP\"\"\"\n    try:\n        if not ip or ip == '::1':  # localhost IPv6\n            return False\n        \n        # Check private IP ranges\n        if (ip.startswith(('10.', '127.')) or  # 10.0.0.0/8, 127.0.0.0/8\n            ip.startswith(('192.168.')) or     # 192.168.0.0/16\n            ip.startswith(('169.254.'))):      # 169.254.0.0/16 (link-local)\n            return False\n        \n        # Check 172.16.0.0/12 private range (172.16.0.0 to 172.31.255.255)\n        if ip.startswith('172.'):\n            parts = ip.split('.')\n            if len(parts) >= 2:\n                try:\n                    second_octet = int(parts[1])\n                    if 16 <= second_octet <= 31:\n                        return False\n                except ValueError:\n                    pass\n        \n        return True\n        \n    except Exception:\n        return False\n\ndef get_ip_geolocation(ip_address):\n    \"\"\"Get geolocation information for an IP address using ipapi.co\"\"\"\n    try:\n        # Check if it's a private IP\n        if ip_address.startswith(('10.', '172.', '192.168.', '127.')):\n            return {\n                'ip': ip_address,\n                'country': 'Private Network',\n                'region': 'Internal',\n                'city': 'Local Network',\n                'isp': 'Private IP Range',\n                'org': 'Internal Network',\n                'timezone': 'Local',\n                'postal': 'N/A'\n            }\n        \n        # Use ipapi.co free service (no API key required)\n        try:\n            response = requests.get(f'https://ipapi.co/{ip_address}/json/', timeout=10)\n            if response.status_code == 200:\n                data = response.json()\n                \n                # Check for error in response\n                if 'error' in data:\n                    raise Exception(data.get('reason', 'Unknown error'))\n                \n                return {\n                    'ip': ip_address,\n                    'country': data.get('country_name', 'Unknown'),\n                    'region': data.get('region', 'Unknown'),\n                    'city': data.get('city', 'Unknown'),\n                    'isp': data.get('org', 'Unknown'),\n                    'org': data.get('org', 'Unknown'),\n                    'timezone': data.get('timezone', 'Unknown'),\n                    'postal': data.get('postal', 'Unknown'),\n                    'loc': f\"{data.get('latitude', 'Unknown')},{data.get('longitude', 'Unknown')}\" if data.get('latitude') and data.get('longitude') else None\n                }\n        except:\n            pass\n        \n        # Fallback to ipinfo.io (also free, no API key required)\n        try:\n            response = requests.get(f'https://ipinfo.io/{ip_address}/json', timeout=10)\n            if response.status_code == 200:\n                data = response.json()\n                \n                return {\n                    'ip': ip_address,\n                    'country': data.get('country', 'Unknown'),\n                    'region': data.get('region', 'Unknown'),\n                    'city': data.get('city', 'Unknown'),\n                    'isp': data.get('org', 'Unknown'),\n                    'org': data.get('org', 'Unknown'),\n                    'timezone': data.get('timezone', 'Unknown'),\n                    'postal': data.get('postal', 'Unknown'),\n                    'loc': data.get('loc'),\n                    'hostname': data.get('hostname')\n                }\n        except:\n            pass\n        \n        # If all services fail, return basic info\n        return {\n            'ip': ip_address,\n            'country': 'Unknown',\n            'region': 'Unknown',\n            'city': 'Unknown',\n            'isp': 'Unknown',\n            'org': 'Unknown',\n            'timezone': 'Unknown',\n            'postal': 'Unknown',\n            'error': 'Geolocation services temporarily unavailable'\n        }\n        \n    except Exception as e:\n        return {\n            'ip': ip_address,\n            'error': f'Error getting geolocation: {str(e)}'\n        }","size_bytes":15919},"app_routes.py":{"content":"import os\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom flask import session, render_template, request, redirect, url_for, flash, jsonify, send_from_directory\nfrom werkzeug.utils import secure_filename\nfrom app import app, db\nfrom replit_auth import require_login, make_replit_blueprint\nfrom flask_login import current_user\nfrom models import User, Upload, Job, ScanResult, ActivityLog\nfrom utils.hash_utils import calculate_hash, compare_hashes\nfrom utils.crypto_utils import encrypt_file, decrypt_file\nfrom utils.password_cracker import start_brute_force, check_job_status\nfrom utils.scanner_utils import scan_url, scan_file_for_malware, vulnerability_scan\nfrom utils.password_analyzer import analyze_password_strength, generate_password_suggestions\nfrom utils.network_utils import ping_host, dns_lookup, port_scan, traceroute, whois_lookup, network_info\nfrom utils.osint_utils import check_email_breaches, search_username, analyze_ip, analyze_domain, get_user_public_ip, get_ip_geolocation\nfrom utils.steganography import encode_text_in_any_file, decode_text_from_any_file, get_file_capacity, validate_file_format, create_stego_filename\n\napp.register_blueprint(make_replit_blueprint(), url_prefix=\"/auth\")\n\n# Make session permanent\n@app.before_request\ndef make_session_permanent():\n    session.permanent = True\n\ndef log_activity(action, details=None):\n    \"\"\"Log user activity\"\"\"\n    # Get the user's real public IP address\n    public_ip = get_user_public_ip(request)\n    \n    log = ActivityLog(\n        user_id=current_user.id if current_user.is_authenticated else None,\n        action=action,\n        details=details,\n        ip_address=request.remote_addr,  # Keep internal IP for debugging\n        user_public_ip=public_ip,  # Store real public IP\n        user_agent=request.headers.get('User-Agent')\n    )\n    db.session.add(log)\n    db.session.commit()\n\n@app.route('/')\ndef index():\n    \"\"\"Home page with service modules for authenticated users, landing page for anonymous users\"\"\"\n    return render_template('index.html')\n\n@app.route('/services')\ndef services():\n    \"\"\"Services provided page\"\"\"\n    return render_template('services.html')\n\n@app.route('/about')\ndef about():\n    \"\"\"About us page\"\"\"\n    return render_template('about.html')\n\n# Individual service GET routes for direct access from home page\n@app.route('/hash-calculator')\n@require_login\ndef hash_calculator_page():\n    \"\"\"Hash Calculator service page\"\"\"\n    return render_template('services/hash_calculator.html')\n\n@app.route('/file-encryption')\n@require_login  \ndef file_encryption_page():\n    \"\"\"File Encryption service page\"\"\"\n    return render_template('services/file_encryption.html')\n\n@app.route('/password-cracker')\n@require_login\ndef password_cracker_page():\n    \"\"\"Password Cracker service page\"\"\"\n    return render_template('services/password_cracker.html')\n\n@app.route('/hash-comparison')\n@require_login\ndef hash_comparison_page():\n    \"\"\"Hash Comparison service page\"\"\"\n    return render_template('services/hash_comparison.html')\n\n@app.route('/url-scanner')\n@require_login\ndef url_scanner_page():\n    \"\"\"URL & Malware Scanner service page\"\"\"\n    return render_template('services/url_scanner.html')\n\n@app.route('/vulnerability-scanner')\n@require_login\ndef vulnerability_scanner_page():\n    \"\"\"Vulnerability Scanner service page\"\"\"\n    return render_template('services/vulnerability_scanner.html')\n\n@app.route('/password-analyzer')\n@require_login\ndef password_analyzer_page():\n    \"\"\"Password Strength Analyzer service page\"\"\"\n    return render_template('services/password_analyzer.html')\n\n@app.route('/network-tools')\n@require_login\ndef network_tools_page():\n    \"\"\"Network Diagnostic Tools service page\"\"\"\n    return render_template('services/network_tools.html')\n\n@app.route('/osint')\n@require_login\ndef osint_page():\n    \"\"\"OSINT Intelligence Gathering service page\"\"\"\n    return render_template('services/osint.html')\n\n@app.route('/osint/analyze', methods=['POST'])\n@require_login\ndef osint_analyze():\n    \"\"\"Analyze OSINT data based on type\"\"\"\n    try:\n        data = request.get_json()\n        osint_type = data.get('type')\n        osint_data = data.get('data')\n        \n        if not osint_type or not osint_data:\n            return jsonify({'error': 'Missing type or data'}), 400\n        \n        result = {}\n        \n        if osint_type == 'email':\n            email = osint_data.get('email')\n            if not email:\n                return jsonify({'error': 'Email address required'}), 400\n            \n            result = check_email_breaches(email)\n            log_activity('osint_email', f'Email: {email}')\n            \n        elif osint_type == 'username':\n            username = osint_data.get('username')\n            if not username:\n                return jsonify({'error': 'Username required'}), 400\n                \n            result = search_username(username)\n            log_activity('osint_username', f'Username: {username}')\n            \n        elif osint_type == 'ip':\n            ip_address = osint_data.get('ip_address')\n            if not ip_address:\n                return jsonify({'error': 'IP address required'}), 400\n                \n            result = analyze_ip(ip_address)\n            log_activity('osint_ip', f'IP: {ip_address}')\n            \n        elif osint_type == 'domain':\n            domain = osint_data.get('domain')\n            if not domain:\n                return jsonify({'error': 'Domain required'}), 400\n                \n            result = analyze_domain(domain)\n            log_activity('osint_domain', f'Domain: {domain}')\n            \n        else:\n            return jsonify({'error': 'Invalid OSINT type'}), 400\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/osint/system-ip', methods=['POST'])\n@require_login\ndef osint_system_ip():\n    \"\"\"Get user's system IP information\"\"\"\n    try:\n        # Get the user's real public IP address from headers\n        public_ip = get_user_public_ip(request)\n        \n        if not public_ip:\n            # If we can't detect from headers, return a message for client-side detection\n            return jsonify({\n                'error': 'Server cannot detect your public IP from headers. Please use client-side detection.',\n                'use_client_detection': True\n            }), 200\n        \n        # Get geolocation information for the IP\n        ip_info = get_ip_geolocation(public_ip)\n        \n        # Log the activity\n        log_activity('osint_system_ip', f'System IP detected: {public_ip}')\n        \n        return jsonify(ip_info)\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/steganography')\n@require_login\ndef steganography_page():\n    \"\"\"Steganography Tool service page\"\"\"\n    return render_template('services/steganography.html')\n\n@app.route('/steganography/capacity', methods=['POST'])\n@require_login\ndef steganography_capacity():\n    \"\"\"Check image capacity for steganography\"\"\"\n    try:\n        if 'image' not in request.files:\n            return jsonify({'error': 'No image file provided'}), 400\n        \n        file = request.files['image']\n        if not file.filename or file.filename == '':\n            return jsonify({'error': 'No file selected'}), 400\n        \n        # Save temporary file to check capacity\n        filename = secure_filename(file.filename)\n        temp_path = os.path.join(app.config.get('UPLOAD_FOLDER', 'uploads'), f\"temp_{filename}\")\n        os.makedirs(os.path.dirname(temp_path), exist_ok=True)\n        file.save(temp_path)\n        \n        try:\n            capacity = get_file_capacity(temp_path)\n            return jsonify({\n                'success': True,\n                'capacity': capacity\n            })\n        finally:\n            # Clean up temp file\n            if os.path.exists(temp_path):\n                os.remove(temp_path)\n                \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/steganography/encode', methods=['POST'])\n@require_login\ndef steganography_encode():\n    \"\"\"Encode text in image using steganography\"\"\"\n    try:\n        if 'cover_image' not in request.files or 'secret_text' not in request.form:\n            return jsonify({'error': 'Missing image file or secret text'}), 400\n        \n        file = request.files['cover_image']\n        secret_text = request.form['secret_text']\n        \n        if not file.filename or file.filename == '':\n            return jsonify({'error': 'No file selected'}), 400\n        \n        if not secret_text.strip():\n            return jsonify({'error': 'Secret text cannot be empty'}), 400\n        \n        # Validate file format\n        filename = secure_filename(file.filename)\n        temp_input_path = os.path.join(app.config.get('UPLOAD_FOLDER', 'uploads'), f\"input_{filename}\")\n        os.makedirs(os.path.dirname(temp_input_path), exist_ok=True)\n        file.save(temp_input_path)\n        \n        try:\n            # Validate image format\n            if not validate_file_format(temp_input_path):\n                return jsonify({'error': 'Unsupported file format or corrupted file'}), 400\n            \n            # Create output filename\n            stego_filename = create_stego_filename(filename)\n            output_path = os.path.join(app.config.get('UPLOAD_FOLDER', 'uploads'), stego_filename)\n            \n            # Encode text in image\n            success, message = encode_text_in_any_file(temp_input_path, secret_text, output_path)\n            \n            if success:\n                # Get file statistics\n                original_size = os.path.getsize(temp_input_path)\n                stego_size = os.path.getsize(output_path)\n                capacity = get_file_capacity(temp_input_path)\n                capacity_used = (len(secret_text) / capacity * 100) if capacity > 0 else 0\n                \n                log_activity('steganography_encode', f'Text length: {len(secret_text)} chars')\n                \n                return jsonify({\n                    'success': True,\n                    'message': message,\n                    'download_url': url_for('uploaded_file', filename=stego_filename),\n                    'original_size': f\"{original_size:,} bytes\",\n                    'stego_size': f\"{stego_size:,} bytes\",\n                    'text_length': len(secret_text),\n                    'capacity_used': f\"{capacity_used:.1f}\"\n                })\n            else:\n                return jsonify({'error': message}), 400\n                \n        finally:\n            # Clean up temp input file\n            if os.path.exists(temp_input_path):\n                os.remove(temp_input_path)\n                \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/steganography/decode', methods=['POST'])\n@require_login\ndef steganography_decode():\n    \"\"\"Decode text from stego image\"\"\"\n    try:\n        if 'stego_image' not in request.files:\n            return jsonify({'error': 'No image file provided'}), 400\n        \n        file = request.files['stego_image']\n        \n        if not file.filename or file.filename == '':\n            return jsonify({'error': 'No file selected'}), 400\n        \n        # Save temporary file\n        filename = secure_filename(file.filename)\n        temp_path = os.path.join(app.config.get('UPLOAD_FOLDER', 'uploads'), f\"decode_{filename}\")\n        os.makedirs(os.path.dirname(temp_path), exist_ok=True)\n        file.save(temp_path)\n        \n        try:\n            # Decode text from image\n            success, result = decode_text_from_any_file(temp_path)\n            \n            if success:\n                log_activity('steganography_decode', f'Extracted {len(result)} chars')\n                \n                return jsonify({\n                    'success': True,\n                    'hidden_text': result,\n                    'text_length': len(result)\n                })\n            else:\n                return jsonify({\n                    'success': False,\n                    'error': result\n                })\n                \n        finally:\n            # Clean up temp file\n            if os.path.exists(temp_path):\n                os.remove(temp_path)\n                \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/dashboard')\n@require_login\ndef dashboard():\n    \"\"\"Main dashboard with all security modules\"\"\"\n    # Get service usage statistics from ActivityLog\n    service_usage = {}\n    \n    # Define all 10 services with their action names and display info\n    services = {\n        'hash_calculation': {'name': 'Hash Calculator', 'icon': 'fas fa-calculator'},\n        'file_encryption': {'name': 'File Encryption', 'icon': 'fas fa-lock'},\n        'file_decryption': {'name': 'File Decryption', 'icon': 'fas fa-unlock'},\n        'brute_force_start': {'name': 'Password Cracker', 'icon': 'fas fa-hammer'},\n        'hash_comparison': {'name': 'Hash Comparison', 'icon': 'fas fa-balance-scale'},\n        'url_scan': {'name': 'URL Scanner', 'icon': 'fas fa-link'},\n        'file_scan': {'name': 'Malware Scanner', 'icon': 'fas fa-shield-virus'},\n        'vulnerability_scan': {'name': 'Vulnerability Scanner', 'icon': 'fas fa-bug'},\n        'password_analysis': {'name': 'Password Analyzer', 'icon': 'fas fa-key'},\n        'network_tools': {'name': 'Network Tools', 'icon': 'fas fa-network-wired'},\n        'osint_email': {'name': 'OSINT Email', 'icon': 'fas fa-envelope'},\n        'osint_username': {'name': 'OSINT Username', 'icon': 'fas fa-user'},\n        'osint_ip': {'name': 'OSINT IP', 'icon': 'fas fa-globe'},\n        'osint_domain': {'name': 'OSINT Domain', 'icon': 'fas fa-server'}\n    }\n    \n    # Count usage for each service from ActivityLog\n    for action_name, service_info in services.items():\n        count = ActivityLog.query.filter_by(action=action_name).count()\n        \n        # Also count network tool specific actions for the network tools category\n        if action_name == 'network_tools':\n            network_actions = ['network_ping', 'network_dns', 'network_portscan', \n                             'network_traceroute', 'network_whois', 'network_info']\n            network_count = 0\n            for net_action in network_actions:\n                network_count += ActivityLog.query.filter_by(action=net_action).count()\n            count = network_count\n        \n        service_usage[action_name] = {\n            'name': service_info['name'],\n            'icon': service_info['icon'],\n            'count': count\n        }\n    \n    # Sort services by usage count (descending)\n    sorted_services = sorted(service_usage.items(), key=lambda x: x[1]['count'], reverse=True)\n    \n    # Get real-time statistics \n    total_scans_today = ScanResult.query.filter(\n        db.func.date(ScanResult.created_at) == db.func.current_date()\n    ).count()\n    \n    active_jobs_count = Job.query.filter_by(status='running').count()\n    \n    total_activities = ActivityLog.query.count()\n    successful_activities = ActivityLog.query.filter(\n        ~ActivityLog.details.ilike('%error%'),\n        ~ActivityLog.details.ilike('%fail%'),\n        ~ActivityLog.details.ilike('%unable%'),\n        ~ActivityLog.details.ilike('%denied%')\n    ).count()\n    \n    success_rate = round((successful_activities / max(total_activities, 1)) * 100, 1)\n    \n    # Get activity timeline data broken down by activity type (last 7 days)\n    activity_timeline = db.session.query(\n        db.func.date(ActivityLog.created_at).label('date'),\n        ActivityLog.action.label('action'),\n        db.func.count(ActivityLog.id).label('count')\n    ).filter(\n        ActivityLog.created_at >= datetime.utcnow() - timedelta(days=6)\n    ).group_by(\n        db.func.date(ActivityLog.created_at),\n        ActivityLog.action\n    ).order_by('date', 'action').all()\n    \n    # Activity type mapping for user-friendly names\n    activity_mapping = {\n        'hash_calculation': 'Hash Calculator',\n        'vulnerability_scan': 'Vulnerability Scanner', \n        'network_ping': 'Network Ping',\n        'password_analysis': 'Password Analysis',\n        'brute_force_start': 'Brute Force Attack',\n        'url_scan': 'URL Scanner',\n        'network_whois': 'WHOIS Lookup',\n        'osint_username': 'OSINT Username',\n        'osint_domain': 'OSINT Domain',\n        'osint_email': 'OSINT Email',\n        'osint_ip': 'OSINT IP',\n        'osint_system_ip': 'System IP Detection',\n        'file_encryption': 'File Encryption',\n        'file_decryption': 'File Decryption',\n        'network_info': 'Network Info',\n        'steganography_encode': 'Steganography Encode',\n        'steganography_decode': 'Steganography Decode',\n        'file_scan': 'File Scanner',\n        'network_traceroute': 'Traceroute',\n        'hash_comparison': 'Hash Comparison',\n        'network_dns': 'DNS Lookup',\n        'network_portscan': 'Port Scanner'\n    }\n    \n    # Organize timeline data by activity type\n    timeline_by_type = {}\n    for day in activity_timeline:\n        activity_name = activity_mapping.get(day.action, day.action)\n        if activity_name not in timeline_by_type:\n            timeline_by_type[activity_name] = {}\n        timeline_by_type[activity_name][str(day.date)] = day.count\n    \n    # Convert to format needed for charts (get top 5 most active types)\n    top_activities = db.session.query(\n        ActivityLog.action,\n        db.func.count(ActivityLog.id).label('total')\n    ).filter(\n        ActivityLog.created_at >= datetime.utcnow() - timedelta(days=6)\n    ).group_by(ActivityLog.action).order_by(db.text('total DESC')).limit(5).all()\n    \n    timeline_data = {\n        'activities': [activity_mapping.get(act.action, act.action) for act in top_activities],\n        'data': timeline_by_type\n    }\n    \n    # Get service usage data for charts\n    chart_data = []\n    chart_labels = []\n    for service_key, service_data in sorted_services[:10]:  # Top 10 services\n        if service_data['count'] > 0:\n            chart_data.append(service_data['count'])\n            chart_labels.append(service_data['name'])\n    \n    return render_template('dashboard.html', \n                         service_usage=sorted_services,\n                         total_scans_today=total_scans_today,\n                         active_jobs_count=active_jobs_count,\n                         success_rate=success_rate,\n                         total_activities=total_activities,\n                         timeline_data=timeline_data,\n                         chart_data=chart_data,\n                         chart_labels=chart_labels)\n\n@app.route('/activity')\n@require_login\ndef activity():\n    \"\"\"Activity history page\"\"\"\n    # Get recent jobs for current user (background tasks like brute force)\n    recent_jobs = Job.query.filter_by(user_id=current_user.id).order_by(Job.created_at.desc()).limit(10).all()\n    \n    # Get recent activities for current user (all other operations)\n    recent_activities = ActivityLog.query.filter_by(user_id=current_user.id).order_by(ActivityLog.created_at.desc()).limit(15).all()\n    \n    # Combine jobs and activities into a unified list\n    all_recent_tasks = []\n    \n    # Add jobs to the list\n    for job in recent_jobs:\n        all_recent_tasks.append({\n            'type': 'job',\n            'title': job.job_type.replace('_', ' ').title(),\n            'details': f\"Status: {job.status.title()}\",\n            'timestamp': job.created_at,\n            'status': job.status,\n            'icon': 'fa-hammer' if 'brute' in job.job_type.lower() else 'fa-cog'\n        })\n    \n    # Add activities to the list\n    activity_icons = {\n        'hash_calculation': 'fa-calculator',\n        'file_encryption': 'fa-lock',\n        'file_decryption': 'fa-unlock',\n        'hash_comparison': 'fa-balance-scale',\n        'url_scan': 'fa-link',\n        'file_scan': 'fa-shield-virus',\n        'vulnerability_scan': 'fa-bug',\n        'password_analysis': 'fa-key',\n        'network_ping': 'fa-satellite-dish',\n        'network_dns': 'fa-search',\n        'network_portscan': 'fa-door-open',\n        'network_traceroute': 'fa-route',\n        'network_whois': 'fa-info-circle',\n        'network_info': 'fa-network-wired'\n    }\n    \n    for activity in recent_activities:\n        # Get friendly name for the activity\n        activity_names = {\n            'hash_calculation': 'Hash Calculation',\n            'file_encryption': 'File Encryption',\n            'file_decryption': 'File Decryption',\n            'hash_comparison': 'Hash Comparison',\n            'url_scan': 'URL Scan',\n            'file_scan': 'Malware Scan',\n            'vulnerability_scan': 'Vulnerability Scan',\n            'password_analysis': 'Password Analysis',\n            'network_ping': 'Network Ping',\n            'network_dns': 'DNS Lookup',\n            'network_portscan': 'Port Scan',\n            'network_traceroute': 'Traceroute',\n            'network_whois': 'WHOIS Lookup',\n            'network_info': 'Network Info'\n        }\n        \n        all_recent_tasks.append({\n            'type': 'activity',\n            'title': activity_names.get(activity.action, activity.action.replace('_', ' ').title()),\n            'details': activity.details or 'Task completed',\n            'timestamp': activity.created_at,\n            'status': 'completed',\n            'icon': activity_icons.get(activity.action, 'fa-cog')\n        })\n    \n    # Sort all tasks by timestamp (most recent first)\n    all_recent_tasks.sort(key=lambda x: x['timestamp'], reverse=True)\n    \n    # Limit to 20 most recent tasks\n    all_recent_tasks = all_recent_tasks[:20]\n    \n    # Get recent scans for current user\n    recent_scans = ScanResult.query.filter_by(user_id=current_user.id).order_by(ScanResult.created_at.desc()).limit(10).all()\n    \n    # Get statistics\n    total_jobs = Job.query.filter_by(user_id=current_user.id).count()\n    completed_jobs = Job.query.filter_by(user_id=current_user.id, status='completed').count()\n    running_jobs = Job.query.filter_by(user_id=current_user.id, status='running').count()\n    total_scans = ScanResult.query.filter_by(user_id=current_user.id).count()\n    total_activities = ActivityLog.query.filter_by(user_id=current_user.id).count()\n    \n    # Calculate successful activities (activities without error keywords)\n    successful_activities = ActivityLog.query.filter(\n        ActivityLog.user_id == current_user.id,\n        ~ActivityLog.details.ilike('%error%'),\n        ~ActivityLog.details.ilike('%fail%'),\n        ~ActivityLog.details.ilike('%unable%'),\n        ~ActivityLog.details.ilike('%denied%')\n    ).count()\n    \n    return render_template('activity.html', \n                         recent_jobs=all_recent_tasks,  # Now contains unified task list\n                         recent_scans=recent_scans,\n                         total_jobs=total_jobs,\n                         completed_jobs=completed_jobs,\n                         running_jobs=running_jobs,\n                         total_scans=total_scans,\n                         total_activities=total_activities,\n                         successful_activities=successful_activities)\n\n@app.route('/hash', methods=['GET', 'POST'])\n@require_login\ndef hash_calculator():\n    \"\"\"Calculate file or text hashes\"\"\"\n    if request.method == 'GET':\n        return render_template('services/hash_calculator.html')\n    \n    try:\n        hash_type = request.form.get('hash_type', 'sha256')\n        input_method = request.form.get('input_method', 'file')\n        \n        if input_method == 'file' and 'file' in request.files and request.files['file'].filename:\n            file = request.files['file']\n            file_content = file.read()\n            result = calculate_hash(file_content, hash_type)\n            input_source = f\"File: {file.filename}\"\n            input_size = f\"{len(file_content):,} bytes\"\n            log_activity('hash_calculation', f'File: {file.filename}, Type: {hash_type}')\n        else:\n            text = request.form.get('text', '')\n            if not text.strip():\n                return jsonify({'success': False, 'error': 'Please provide text to hash'})\n            result = calculate_hash(text.encode(), hash_type)\n            input_source = \"Text input\"\n            input_size = f\"{len(text):,} characters\"\n            log_activity('hash_calculation', f'Text hash, Type: {hash_type}')\n        \n        return jsonify({\n            'success': True,\n            'hash_type': hash_type.upper(),\n            'hash_result': result,\n            'input_source': input_source,\n            'input_size': input_size,\n            'hash_length': len(result)\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Error calculating hash: {str(e)}'})\n\n@app.route('/encrypt', methods=['POST'])\n@require_login\ndef encrypt():\n    \"\"\"Encrypt a file with AES\"\"\"\n    try:\n        if 'file' not in request.files:\n            return jsonify({'success': False, 'error': 'No file selected'})\n        \n        file = request.files['file']\n        password = request.form.get('password')\n        \n        if not password:\n            return jsonify({'success': False, 'error': 'Password is required for encryption'})\n        \n        if not file.filename:\n            return jsonify({'success': False, 'error': 'No file selected'})\n        \n        # Save uploaded file\n        filename = secure_filename(file.filename)\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(file_path)\n        \n        # Get original file size\n        original_size = os.path.getsize(file_path)\n        \n        # Encrypt file\n        encrypted_path = encrypt_file(file_path, password)\n        encrypted_filename = os.path.basename(encrypted_path)\n        encrypted_size = os.path.getsize(encrypted_path)\n        \n        # Log upload\n        upload = Upload(\n            user_id=current_user.id,\n            filename=encrypted_filename,\n            original_filename=file.filename,\n            file_size=encrypted_size\n        )\n        db.session.add(upload)\n        db.session.commit()\n        \n        log_activity('file_encryption', f'File: {file.filename}')\n        \n        return jsonify({\n            'success': True,\n            'message': f'File encrypted successfully!',\n            'download_url': url_for('uploaded_file', filename=encrypted_filename),\n            'original_filename': file.filename,\n            'encrypted_filename': encrypted_filename,\n            'original_size': f\"{original_size:,} bytes\",\n            'encrypted_size': f\"{encrypted_size:,} bytes\"\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Encryption failed: {str(e)}'})\n\n@app.route('/decrypt', methods=['POST'])\n@require_login\ndef decrypt():\n    \"\"\"Decrypt a file with AES\"\"\"\n    try:\n        if 'file' not in request.files:\n            return jsonify({'success': False, 'error': 'No file selected'})\n        \n        file = request.files['file']\n        password = request.form.get('password')\n        \n        if not password:\n            return jsonify({'success': False, 'error': 'Password is required for decryption'})\n        \n        if not file.filename:\n            return jsonify({'success': False, 'error': 'No file selected'})\n        \n        # Save uploaded file\n        filename = secure_filename(file.filename)\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(file_path)\n        \n        # Get encrypted file size\n        encrypted_size = os.path.getsize(file_path)\n        \n        # Decrypt file\n        decrypted_path = decrypt_file(file_path, password)\n        decrypted_filename = os.path.basename(decrypted_path)\n        decrypted_size = os.path.getsize(decrypted_path)\n        \n        log_activity('file_decryption', f'File: {file.filename}')\n        \n        return jsonify({\n            'success': True,\n            'message': f'File decrypted successfully!',\n            'download_url': url_for('uploaded_file', filename=decrypted_filename),\n            'original_filename': file.filename,\n            'decrypted_filename': decrypted_filename,\n            'encrypted_size': f\"{encrypted_size:,} bytes\",\n            'decrypted_size': f\"{decrypted_size:,} bytes\"\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Decryption failed: {str(e)}'})\n\n@app.route('/brute/start', methods=['POST'])\n@require_login\ndef start_brute():\n    \"\"\"Start brute force password cracking\"\"\"\n    try:\n        if 'file' not in request.files:\n            return jsonify({'error': 'No file selected'}), 400\n        \n        file = request.files['file']\n        wordlist_type = request.form.get('wordlist', 'common')\n        \n        # Save uploaded file\n        filename = secure_filename(file.filename or 'unknown')\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(file_path)\n        \n        # Handle custom wordlist upload\n        custom_wordlist_path = None\n        if wordlist_type == 'custom' and 'wordlist_file' in request.files:\n            wordlist_file = request.files['wordlist_file']\n            if wordlist_file.filename:\n                wordlist_filename = secure_filename(wordlist_file.filename)\n                custom_wordlist_path = os.path.join(app.config['UPLOAD_FOLDER'], f'wordlist_{wordlist_filename}')\n                wordlist_file.save(custom_wordlist_path)\n        \n        # Create job\n        job = Job(\n            user_id=current_user.id,\n            job_type='brute_force',\n            status='running'\n        )\n        db.session.add(job)\n        db.session.commit()\n        \n        # Start brute force (in background)\n        start_brute_force(job.id, file_path, wordlist_type, custom_wordlist_path)\n        \n        log_activity('brute_force_start', f'File: {file.filename}')\n        \n        return jsonify({'job_id': job.id, 'message': 'Brute force attack started'})\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/job_status/<int:job_id>')\n@require_login\ndef api_job_status(job_id):\n    \"\"\"Get status of a job\"\"\"\n    job = Job.query.get_or_404(job_id)\n    \n    # Ensure user owns this job\n    if job.user_id != current_user.id:\n        return jsonify({'error': 'Access denied'}), 403\n    \n    return jsonify({\n        'status': job.status,\n        'progress': job.progress,\n        'result': job.result,\n        'job_type': job.job_type\n    })\n\n@app.route('/api/cancel_job/<int:job_id>', methods=['POST'])\n@require_login\ndef api_cancel_job(job_id):\n    \"\"\"Cancel a running job\"\"\"\n    job = Job.query.get_or_404(job_id)\n    \n    # Ensure user owns this job\n    if job.user_id != current_user.id:\n        return jsonify({'error': 'Access denied'}), 403\n    \n    job.status = 'cancelled'\n    db.session.commit()\n    \n    return jsonify({'message': 'Job cancelled'})\n\n@app.route('/analyze_password', methods=['POST'])\n@require_login\ndef analyze_password():\n    \"\"\"Analyze password strength\"\"\"\n    try:\n        password = request.form.get('password', '')\n        \n        if not password:\n            return jsonify({'error': 'Password is required'}), 400\n        \n        analysis = analyze_password_strength(password)\n        suggestions = generate_password_suggestions()\n        \n        # Log activity (without storing the actual password)\n        log_activity('password_analysis', f'Password length: {len(password)} chars')\n        \n        return jsonify({\n            'analysis': analysis,\n            'suggestions': suggestions\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/compare', methods=['POST'])\n@require_login\ndef compare():\n    \"\"\"Compare hashes of two files\"\"\"\n    try:\n        if 'file1' not in request.files or 'file2' not in request.files:\n            flash('Please select both files for comparison', 'error')\n            return redirect(url_for('dashboard'))\n        \n        file1 = request.files['file1']\n        file2 = request.files['file2']\n        hash_type = request.form.get('hash_type', 'sha256')\n        \n        content1 = file1.read()\n        content2 = file2.read()\n        \n        result = compare_hashes(content1, content2, hash_type)\n        \n        log_activity('hash_comparison', f'Files: {file1.filename} vs {file2.filename}')\n        \n        if result['match']:\n            flash(f'Files match! Both have {hash_type.upper()} hash: {result[\"hash1\"]}', 'success')\n        else:\n            flash(f'Files do not match.\\n{file1.filename}: {result[\"hash1\"]}\\n{file2.filename}: {result[\"hash2\"]}', 'warning')\n        \n    except Exception as e:\n        flash(f'Comparison failed: {str(e)}', 'error')\n    \n    return redirect(url_for('dashboard'))\n\n@app.route('/scan/url', methods=['POST'])\n@require_login\ndef scan_url_route():\n    \"\"\"Scan URL for safety\"\"\"\n    try:\n        url = request.form.get('url')\n        if not url:\n            return jsonify({'success': False, 'error': 'Please enter a URL to scan'})\n        \n        result = scan_url(url)\n        \n        scan_result = ScanResult(\n            user_id=current_user.id,\n            scan_type='url',\n            target=url,\n            result=str(result),\n            risk_level=result.get('risk_level', 'unknown')\n        )\n        db.session.add(scan_result)\n        db.session.commit()\n        \n        log_activity('url_scan', f'URL: {url}')\n        \n        return jsonify({\n            'success': True,\n            'url': url,\n            'safe': result['safe'],\n            'message': result['message'],\n            'risk_level': result['risk_level'],\n            'reasons': result.get('reasons', [])\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'URL scan failed: {str(e)}'})\n\n@app.route('/scan/file', methods=['POST'])\n@require_login\ndef scan_file_route():\n    \"\"\"Scan file for malware\"\"\"\n    try:\n        if 'file' not in request.files:\n            return jsonify({'success': False, 'error': 'No file selected'})\n        \n        file = request.files['file']\n        \n        # Save uploaded file\n        filename = secure_filename(file.filename or 'unknown')\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(file_path)\n        \n        result = scan_file_for_malware(file_path)\n        \n        scan_result = ScanResult(\n            user_id=current_user.id,\n            scan_type='file',\n            target=file.filename,\n            result=str(result),\n            risk_level=result.get('risk_level', 'unknown')\n        )\n        db.session.add(scan_result)\n        db.session.commit()\n        \n        log_activity('file_scan', f'File: {file.filename}')\n        \n        return jsonify({\n            'success': True,\n            'filename': file.filename,\n            'clean': result['clean'],\n            'message': result['message'],\n            'risk_level': result['risk_level'],\n            'reasons': result.get('reasons', [])\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'File scan failed: {str(e)}'})\n\n@app.route('/scan/vulnerability', methods=['POST'])\n@require_login\ndef vulnerability_scan_route():\n    \"\"\"Perform vulnerability scan on URL\"\"\"\n    try:\n        url = request.form.get('url')\n        if not url:\n            return jsonify({'success': False, 'error': 'Please enter a URL to scan'})\n        \n        result = vulnerability_scan(url)\n        \n        scan_result = ScanResult(\n            user_id=current_user.id,\n            scan_type='vulnerability',\n            target=url,\n            result=str(result),\n            risk_level=result.get('risk_level', 'unknown')\n        )\n        db.session.add(scan_result)\n        db.session.commit()\n        \n        log_activity('vulnerability_scan', f'URL: {url}')\n        \n        vulnerabilities = result.get('vulnerabilities', [])\n        return jsonify({\n            'success': True,\n            'url': url,\n            'vulnerabilities': vulnerabilities,\n            'risk_level': result.get('risk_level', 'unknown'),\n            'message': result.get('message', 'Scan completed'),\n            'vulnerability_count': len(vulnerabilities),\n            'reasons': result.get('reasons', []),\n            'security_issues': result.get('security_issues', []),\n            'security_strengths': result.get('security_strengths', []),\n            'missing_headers': result.get('missing_headers', []),\n            'present_headers': result.get('present_headers', [])\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Vulnerability scan failed: {str(e)}'})\n\n@app.route('/network/ping', methods=['POST'])\n@require_login\ndef network_ping():\n    \"\"\"Ping a hostname or IP address\"\"\"\n    try:\n        hostname = request.form.get('hostname')\n        count = int(request.form.get('count', 4))\n        \n        if not hostname:\n            return jsonify({'success': False, 'error': 'Hostname is required'})\n        \n        result = ping_host(hostname, count)\n        log_activity('network_ping', f'Host: {hostname}')\n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Ping failed: {str(e)}'})\n\n@app.route('/network/dns', methods=['POST'])\n@require_login\ndef network_dns():\n    \"\"\"DNS lookup for hostname\"\"\"\n    try:\n        hostname = request.form.get('hostname')\n        record_type = request.form.get('record_type', 'A')\n        \n        if not hostname:\n            return jsonify({'success': False, 'error': 'Hostname is required'})\n        \n        result = dns_lookup(hostname, record_type)\n        log_activity('network_dns', f'Host: {hostname}, Type: {record_type}')\n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'DNS lookup failed: {str(e)}'})\n\n@app.route('/network/portscan', methods=['POST'])\n@require_login\ndef network_portscan():\n    \"\"\"Port scan for hostname\"\"\"\n    try:\n        hostname = request.form.get('hostname')\n        ports = request.form.get('ports', '80,443,22,21,25,53,110,143,993,995')\n        \n        if not hostname:\n            return jsonify({'success': False, 'error': 'Hostname is required'})\n        \n        result = port_scan(hostname, ports)\n        log_activity('network_portscan', f'Host: {hostname}, Ports: {ports}')\n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Port scan failed: {str(e)}'})\n\n@app.route('/network/traceroute', methods=['POST'])\n@require_login\ndef network_traceroute():\n    \"\"\"Traceroute to hostname\"\"\"\n    try:\n        hostname = request.form.get('hostname')\n        max_hops = int(request.form.get('max_hops', 15))\n        \n        if not hostname:\n            return jsonify({'success': False, 'error': 'Hostname is required'})\n        \n        result = traceroute(hostname, max_hops)\n        log_activity('network_traceroute', f'Host: {hostname}')\n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Traceroute failed: {str(e)}'})\n\n@app.route('/network/whois', methods=['POST'])\n@require_login\ndef network_whois():\n    \"\"\"WHOIS lookup for domain\"\"\"\n    try:\n        domain = request.form.get('domain')\n        \n        if not domain:\n            return jsonify({'success': False, 'error': 'Domain is required'})\n        \n        result = whois_lookup(domain)\n        log_activity('network_whois', f'Domain: {domain}')\n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'WHOIS lookup failed: {str(e)}'})\n\n@app.route('/network/info', methods=['GET'])\n@require_login\ndef network_info_route():\n    \"\"\"Get network information\"\"\"\n    try:\n        result = network_info()\n        log_activity('network_info', 'Network information retrieved')\n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Network info failed: {str(e)}'})\n\n@app.route('/admin')\n@require_login\ndef admin_panel():\n    \"\"\"Admin panel for viewing logs and user management\"\"\"\n    if current_user.role != 'admin':\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    logs = ActivityLog.query.order_by(ActivityLog.created_at.desc()).limit(100).all()\n    users = User.query.all()\n    return render_template('admin.html', logs=logs, users=users)\n\n\n@app.route('/uploads/<filename>')\n@require_login\ndef uploaded_file(filename):\n    \"\"\"Serve uploaded files\"\"\"\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\n# Create upload directory if it doesn't exist\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n","size_bytes":40976}},"version":1}